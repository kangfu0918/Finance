# -*- coding: utf-8 -*-
"""MMAI 823 Crypto Trading - Statistical Arbitrage with LSTM and features KP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19O4GVewGwIvFv_KSyO-o3rqnEFIEMFwd
"""

# package installation
!pip install pycoingecko
!pip install yfinance

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, LSTM
from tensorflow.keras import optimizers
from tensorflow.keras.callbacks import ModelCheckpoint, EarlyStopping
from sklearn.preprocessing import MinMaxScaler

# Package loading
import pandas as pd
import numpy as np
from pycoingecko import CoinGeckoAPI
cg = CoinGeckoAPI()

from datetime import datetime
from datetime import timedelta
import time

days_back = 570

datestamp = datetime.date(datetime.now())
datestamp = datestamp.strftime("%d-%m-%Y")
df_test_ltc = cg.get_coin_history_by_id(id='litecoin', vs_currency='usd', date=datestamp)
df_tst = df_test_ltc['developer_data']
cols = list(df_tst)
lst_forks = []
lst_stars = []
lst_subscribers = []

for i in range(0, days_back+1):
  datestamp = datetime.strptime(datestamp, "%d-%m-%Y")
  datestamp = datestamp - timedelta(days=1)
  datestamp = datestamp.strftime("%d-%m-%Y")
  df_test_ltc = cg.get_coin_history_by_id(id='litecoin', vs_currency='usd', date=datestamp)
  df_test_forks = df_test_ltc['developer_data']['forks']
  df_test_stars = df_test_ltc['developer_data']['stars']
  df_test_subscribers = df_test_ltc['developer_data']['subscribers']
  lst_forks.append([df_test_forks])
  lst_stars.append([df_test_stars])
  lst_subscribers.append([df_test_subscribers])
  
  #coingecko API limit is 50 queries per minute. Hold for 1 minute every 50 queries
  if i%49 == 0 and i > 0:
    time.sleep(120)
  #df_test_all = pd.concat([df_test], axis=0)
#df_test_all = pd.DataFrame(zip(lst, cols))
#df_test_all = df_test_all.drop([1],axis=1)
#df_test_all = pd.DataFrame({'Forks':[lst_forks], 'Stars':[lst_stars], 'Subscribers':[lst_subscribers]})
df_test_all_forks = pd.DataFrame(lst_forks)
df_test_all_stars = pd.DataFrame(lst_stars)
df_test_all_subscribers = pd.DataFrame(lst_subscribers)
df_test_all = pd.concat([df_test_all_forks, df_test_all_stars, df_test_all_subscribers], axis=1)
df_test_all.columns = ['Forks', 'Stars', 'Subscribers']
df_test_all

df_test_all = df_test_all.iloc[::-1].reset_index(drop=True)

# Commented out IPython magic to ensure Python compatibility.
import seaborn as sns
import matplotlib.pyplot as plt
# %pylab inline
pylab.rcParams['figure.figsize'] = (20.0, 10.0)
font = {'family' : 'normal',
        'weight' : 'normal',
        'size'   : 22}

matplotlib.rc('font', **font)

#Plot Features
df_test_all['Forks'].plot()

df_test_all['Stars'].plot()

df_test_all['Subscribers'].plot()

#linearly interpolate for any missing values
df_test_all['Forks'] = df_test_all['Forks'].interpolate(method='linear', axis=0)
df_test_all['Stars'] = df_test_all['Stars'].interpolate(method='linear', axis=0)
df_test_all['Subscribers'] = df_test_all['Subscribers'].interpolate(method='linear', axis=0)

#Plot Features after interpolation
df_test_all['Forks'].plot()

df_test_all['Stars'].plot()

df_test_all['Subscribers'].plot()

#Load daily Tether price data from the past ~2 years
dfs = pd.DataFrame(cg.get_coin_market_chart_by_id(id='solana', vs_currency='usd', days=days_back)['prices'])

dfs = dfs.drop([0],axis=1)
dfs = dfs.rename(columns={1: "sol_price"})

dfs

#Load daily Binance Coin price data from the past ~2 years
dfbin = pd.DataFrame(cg.get_coin_market_chart_by_id(id='binancecoin', vs_currency='usd', days=days_back)['prices'])

dfbin = dfbin.drop([0],axis=1)
dfbin = dfbin.rename(columns={1: "bin_price"})

dfbin

#Load daily Cardano price data from the past ~2 years
dfc = pd.DataFrame(cg.get_coin_market_chart_by_id(id='cardano', vs_currency='usd', days=days_back)['prices'])

dfc = dfc.drop([0],axis=1)
dfc = dfc.rename(columns={1: "car_price"})

dfc

#Load daily Cardano price data from the past ~2 years
dfa = pd.DataFrame(cg.get_coin_market_chart_by_id(id='avalanche-2', vs_currency='usd', days=days_back)['prices'])

dfa = dfa.drop([0],axis=1)
dfa = dfa.rename(columns={1: "ave_price"})

dfa

#Load daily BTC price data from the past ~2 years
dfb = pd.DataFrame(cg.get_coin_market_chart_by_id(id='bitcoin', vs_currency='usd', days=days_back)['prices'])

dfb = dfb.drop([0],axis=1)
dfb = dfb.rename(columns={1: "btc_price"})

dfb

#Load daily ETH price data from the past ~2 years
dfe = pd.DataFrame(cg.get_coin_market_chart_by_id(id='ethereum', vs_currency='usd', days=days_back)['prices'])

dfe = dfe.drop([0],axis=1)
dfe = dfe.rename(columns={1: "eth_price"})

dfe

#Load daily LTC price data from the past ~2 years
dfl = pd.DataFrame(cg.get_coin_market_chart_by_id(id='litecoin', vs_currency='usd', days=days_back)['prices'])

dfl = dfl.drop([0],axis=1)
dfl = dfl.rename(columns={1: "ltc_price"})

dfl

#Load daily DGC price data from the past ~2 years
dfd = pd.DataFrame(cg.get_coin_market_chart_by_id(id='dogecoin', vs_currency='usd', days=days_back)['prices'])

dfd = dfd.drop([0],axis=1)
dfd = dfd.rename(columns={1: "dgc_price"})

dfd

#Load daily TRL price data from the past ~2 years
dftl = pd.DataFrame(cg.get_coin_market_chart_by_id(id='terra-luna', vs_currency='usd', days=days_back)['prices'])

dftl = dftl.drop([0],axis=1)
dftl = dftl.rename(columns={1: "trl_price"})

dftl

#Concatonate BTC, ETH and LTC prices into one DF
df_all = pd.concat([dfl, dfb, dfe, dfs, dfbin, dfc, dfa, dfd, dftl,df_test_all], axis=1)

df_all

df_all.describe()

df_all.hist()

# Commented out IPython magic to ensure Python compatibility.
import seaborn as sns
import matplotlib.pyplot as plt
# %pylab inline
pylab.rcParams['figure.figsize'] = (20.0, 10.0)
font = {'family' : 'normal',
        'weight' : 'normal',
        'size'   : 22}

matplotlib.rc('font', **font)

#Plot Prices
df_all.plot()

#Plot BTC Price with monthly and yearly rolling averages
df_all['btc_price'].plot()
df_all['btc_price'].rolling(window=21).mean().plot(lw=3,label='btc_price rolling ave (monthly)')
df_all['btc_price'].rolling(window=255).mean().plot(lw=3,label='btc_price rolling ave (yearly)')
plt.legend()

#Plot ETH Price with monthly and yearly rolling averages
df_all['eth_price'].plot()
df_all['eth_price'].rolling(window=21).mean().plot(lw=3,label='eth_price rolling ave (monthly)')
df_all['eth_price'].rolling(window=255).mean().plot(lw=3,label='eth_price rolling ave (yearly)')
plt.legend()

#Plot LTC Price with monthly and yearly rolling averages
df_all['ltc_price'].plot()
df_all['ltc_price'].rolling(window=21).mean().plot(lw=3,label='ltc_price rolling ave (monthly)')
df_all['ltc_price'].rolling(window=255).mean().plot(lw=3,label='ltc_price rolling ave (yearly)')
plt.legend()

#Plot THR Price with monthly and yearly rolling averages
df_all['sol_price'].plot()
df_all['sol_price'].rolling(window=21).mean().plot(lw=3,label='sol_price rolling ave (monthly)')
df_all['sol_price'].rolling(window=255).mean().plot(lw=3,label='sol_price rolling ave (yearly)')
plt.legend()

#Plot BIN Price with monthly and yearly rolling averages
df_all['bin_price'].plot()
df_all['bin_price'].rolling(window=21).mean().plot(lw=3,label='bin_price rolling ave (monthly)')
df_all['bin_price'].rolling(window=255).mean().plot(lw=3,label='bin_price rolling ave (yearly)')
plt.legend()

#Plot CAR Price with monthly and yearly rolling averages
df_all['car_price'].plot()
df_all['car_price'].rolling(window=21).mean().plot(lw=3,label='car_price rolling ave (monthly)')
df_all['car_price'].rolling(window=255).mean().plot(lw=3,label='car_price rolling ave (yearly)')
plt.legend()

#Plot AVE Price with monthly and yearly rolling averages
df_all['ave_price'].plot()
df_all['ave_price'].rolling(window=21).mean().plot(lw=3,label='ave_price rolling ave (monthly)')
df_all['ave_price'].rolling(window=255).mean().plot(lw=3,label='ave_price rolling ave (yearly)')
plt.legend()

#Plot DGC Price with monthly and yearly rolling averages
df_all['dgc_price'].plot()
df_all['dgc_price'].rolling(window=21).mean().plot(lw=3,label='dgc_price rolling ave (monthly)')
df_all['dgc_price'].rolling(window=255).mean().plot(lw=3,label='dgc_price rolling ave (yearly)')
plt.legend()

#Plot TRL Price with monthly and yearly rolling averages
df_all['trl_price'].plot()
df_all['trl_price'].rolling(window=21).mean().plot(lw=3,label='trl_price rolling ave (monthly)')
df_all['trl_price'].rolling(window=255).mean().plot(lw=3,label='trl_price rolling ave (yearly)')
plt.legend()

#See Correlation
df_all.corr()['ltc_price'].sort_values(ascending=False)[1:]

#retrain model at the train_freq over trial_period
trial_period = 300
train_freq = 1
look_back = 20
days_projected = 0

# Data frame construction step 1
def construct_data(df, look_back, days_projected):
    X0=[]
    X1=[]
    X2=[]
    X3=[]
    X4=[]
    X5=[]
    X6=[]
    X7=[]
    X8=[]
    X9=[]
    X10=[]
    X11=[]
    y=[]
    
    for i in range (0, df.shape[0]-look_back- days_projected):
        X0.append(df.iloc[i:i + look_back, 0])
        X1.append(df.iloc[i:i + look_back, 1])
        X2.append(df.iloc[i:i + look_back, 2])
        X3.append(df.iloc[i:i + look_back, 3])
        X4.append(df.iloc[i:i + look_back, 4])
        X5.append(df.iloc[i:i + look_back, 5])
        X6.append(df.iloc[i:i + look_back, 6])
        X7.append(df.iloc[i:i + look_back, 7])
        X8.append(df.iloc[i:i + look_back, 8])
        X9.append(df.iloc[i:i + look_back, 9])
        X10.append(df.iloc[i:i + look_back, 10])
        X11.append(df.iloc[i:i + look_back, 11])
        y.append(df.iloc[i + look_back + days_projected, 0])
    
    # y reshape
    y=np.reshape(y,(len(y),-1))

    # Scaler
    scaler = MinMaxScaler(feature_range=(0,1))
    X0 = scaler.fit_transform(X0)
    X1 = scaler.fit_transform(X1)
    X2 = scaler.fit_transform(X2)
    X3 = scaler.fit_transform(X3)
    X4 = scaler.fit_transform(X4)
    X5 = scaler.fit_transform(X5)
    X6 = scaler.fit_transform(X6)
    X7 = scaler.fit_transform(X7)
    X8 = scaler.fit_transform(X8)
    X9 = scaler.fit_transform(X9)
    X10 = scaler.fit_transform(X10)
    X11 = scaler.fit_transform(X11)
    y = scaler.fit_transform(y)

    # stack inputs
    X=np.stack((X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11), axis=2)
    return X, y, scaler

results = []
actuals = []

for i in range(train_freq, trial_period, train_freq):
  day = len(df_all)-trial_period+i
  df_train = df_all.iloc[:day+days_projected+train_freq]
  X, y, scaler = construct_data(df_train,look_back,days_projected)

  # Train test split (latest 5 days for prediction)
  X_train, X_test = X[:-train_freq], X[-train_freq:]
  y_train, y_test = y[:-train_freq], y[-train_freq:]
  X_train.shape[0], X_train.shape[1], X_train.shape[2]

  # Model build
  model = Sequential()
  # set return requesnce = true, if we are going to have another LSTM layer
  model.add(LSTM(50, return_sequences=True, input_shape=(X_train.shape[1], X_train.shape[2])))
  model.add(LSTM(50, return_sequences=False))
  model.add(Dense(50, activation='relu'))
  model.add(Dense(1))

  # Model compile and fit
  model.compile(optimizer='Adam', loss='mse', metrics=['mse'])
  model.fit(X_train, y_train, epochs=80, batch_size=32)

  print(i)

  results.append(scaler.inverse_transform(model.predict(X_test)))
  actuals.append(scaler.inverse_transform(y_test))

predictions = np.concatenate(results)

value = np.concatenate(actuals)

# LTC model vs. Actual for Training set

import matplotlib.pyplot as plt
plt.style.use('fivethirtyeight')
plt.figure(figsize=(12,8))
plt.title('LSTM Litecoin Price Estimate vs. Actual Price')
plt.xlabel('Days', fontsize=14)
plt.ylabel('LTC Price (USD)', fontsize=18)
plt.plot(predictions)
plt.plot(value)
plt.legend(['LSTM Price Estimate', 'Actual Price'])
plt.show()

#Measure MSE for trial period
from sklearn.metrics import mean_squared_error

mean_squared_error(value, predictions)

#Measure r-squared
from sklearn.metrics import r2_score

r2_score(value, predictions)

delta_projected_actual_data = []

# Variables for Trading Strategy trade, position & pnl management:
orders = []  # Container for tracking buy/sell order, +1 for buy order, -1 for sell order, 0 for no-action
positions = []  # Container for tracking positions, +ve for long positions, -ve for short positions, 0 for flat/no position
pnls = []  # Container for tracking total_pnls, this is the sum of closed_pnl i.e. pnls already locked in and open_pnl i.e. pnls for open-position marked to market price

last_buy_price = 0  # Price at which last buy trade was made, used to prevent over-trading at/around the same price
last_sell_price = 0  # Price at which last sell trade was made, used to prevent over-trading at/around the same price
position = 0  # Current position of the trading strategy
buy_sum_price_qty = 0  # Summation of products of buy_trade_price and buy_trade_qty for every buy Trade made since last time being flat
buy_sum_qty = 0  # Summation of buy_trade_qty for every buy Trade made since last time being flat
sell_sum_price_qty = 0  # Summation of products of sell_trade_price and sell_trade_qty for every sell Trade made since last time being flat
sell_sum_qty = 0  # Summation of sell_trade_qty for every sell Trade made since last time being flat
open_pnl = 0  # Open/Unrealized PnL marked to market
closed_pnl = 0  # Closed/Realized PnL so far

# Constants that define strategy behavior/thresholds
StatArb_VALUE_FOR_BUY_ENTRY = 1  # StatArb trading signal value aboe which to enter buy-orders/long-position
StatArb_VALUE_FOR_SELL_ENTRY = -1  # StatArb trading signal value below which to enter sell-orders/short-position
MIN_PRICE_MOVE_FROM_LAST_TRADE = 1 # Minimum price change since last trade before considering trading again, this is to prevent over-trading at/around same prices
NUM_SHARES_PER_TRADE = 10  # Number of currency to buy/sell on every trade
MIN_PROFIT_TO_CLOSE = 1000  # Minimum Open/Unrealized profit at which to close positions and lock profits



for i in range(0, len(predictions)):
    final_delta_projected =  predictions[i][0] - value[i][0]
    delta_projected_actual_data.append(final_delta_projected)
    # This section checks trading signal against trading parameters/thresholds and positions, to trade.
    #
    # We will perform a sell trade at close_prices if the following conditions are met:
    # 1. The StatArb trading signal value is below Sell-Entry threshold and the difference between last trade-price and current-price is different enough.
    # 2. We are long( +ve position ) and current position is profitable enough to lock profit.
    
    if ((final_delta_projected < StatArb_VALUE_FOR_SELL_ENTRY and abs(value[i][0] - last_sell_price) > MIN_PRICE_MOVE_FROM_LAST_TRADE)  # StatArb above sell entry threshold, we should sell
      or (position > 0 and (open_pnl > MIN_PROFIT_TO_CLOSE))):  # long from -ve StatArb and StatArb has gone positive or position is profitable, sell to close position
        orders.append(-1)  # mark the sell trade
        last_sell_price = value[i][0]
        position -= NUM_SHARES_PER_TRADE  # reduce position by the size of this trade
        sell_sum_price_qty += (value[i][0] * NUM_SHARES_PER_TRADE)  # update vwap sell-price
        sell_sum_qty += NUM_SHARES_PER_TRADE
        print("Sell ", NUM_SHARES_PER_TRADE, " @ ", value[i][0], "Position: ", position)
        print("OpenPnL: ", open_pnl, " ClosedPnL: ", closed_pnl, " TotalPnL: ", (open_pnl + closed_pnl))
    # We will perform a buy trade at close_prices if the following conditions are met:
    # 1. The StatArb trading signal value is above Buy-Entry threshold and the difference between last trade-price and current-price is different enough.
    # 2. We are short( -ve position ) and current position is profitable enough to lock profit.
    elif ((final_delta_projected > StatArb_VALUE_FOR_BUY_ENTRY and abs(value[i][0] - last_buy_price) > MIN_PRICE_MOVE_FROM_LAST_TRADE)  # StatArb below buy entry threshold, we should buy
        or (position < 0 and (open_pnl > MIN_PROFIT_TO_CLOSE))):  # short from +ve StatArb and StatArb has gone negative or position is profitable, buy to close position
        orders.append(+1)  # mark the buy trade
        last_buy_price = value[i][0]
        position += NUM_SHARES_PER_TRADE  # increase position by the size of this trade
        buy_sum_price_qty += (value[i][0] * NUM_SHARES_PER_TRADE)  # update the vwap buy-price
        buy_sum_qty += NUM_SHARES_PER_TRADE
        print("Buy ", NUM_SHARES_PER_TRADE, " @ ", value[i][0], "Position: ", position)
        print("OpenPnL: ", open_pnl, " ClosedPnL: ", closed_pnl, " TotalPnL: ", (open_pnl + closed_pnl))
    else:
    # No trade since none of the conditions were met to buy or sell
        orders.append(0)

    positions.append(position)

    # This section updates Open/Unrealized & Closed/Realized positions
    open_pnl = 0
    if position > 0:
        if sell_sum_qty > 0:  # long position and some sell trades have been made against it, close that amount based on how much was sold against this long position
            open_pnl = abs(sell_sum_qty) * (sell_sum_price_qty / sell_sum_qty - buy_sum_price_qty / buy_sum_qty)
        # mark the remaining position to market i.e. pnl would be what it would be if we closed at current price
        open_pnl += abs(sell_sum_qty - position) * (value[i][0] - buy_sum_price_qty / buy_sum_qty)
    elif position < 0:
        if buy_sum_qty > 0:  # short position and some buy trades have been made against it, close that amount based on how much was bought against this short position
            open_pnl = abs(buy_sum_qty) * (sell_sum_price_qty / sell_sum_qty - buy_sum_price_qty / buy_sum_qty)
        # mark the remaining position to market i.e. pnl would be what it would be if we closed at current price
        open_pnl += abs(buy_sum_qty - position) * (sell_sum_price_qty / sell_sum_qty - value[i][0])
    else:
        # flat, so update closed_pnl and reset tracking variables for positions & pnls
        closed_pnl += (sell_sum_price_qty - buy_sum_price_qty)
        buy_sum_price_qty = 0
        buy_sum_qty = 0
        sell_sum_price_qty = 0
        sell_sum_qty = 0
        last_buy_price = 0
        last_sell_price = 0

    pnls.append(closed_pnl + open_pnl)

TRADING_INSTRUMENT = 'ltc_price'

df_trade = pd.DataFrame(delta_projected_actual_data,columns=['delta'])
df_trade['ClosePrice'] = df_all[TRADING_INSTRUMENT].iloc[-trial_period+1:].reset_index(drop=True)
df_trade['Trades'] = orders
df_trade['Position'] = positions
df_trade['PnL'] = pnls

plt.plot(df_trade['ClosePrice'], color='k', lw=1., label='ClosePrice')
plt.plot(df_trade[df_trade['Trades'] == 1].index, df_trade[df_trade['Trades'] == 1].ClosePrice, color='r', lw=0, marker='^', markersize=7, label='buy')
plt.plot(df_trade[df_trade['Trades'] == -1].index, df_trade[df_trade['Trades'] == -1].ClosePrice, color='g', lw=0, marker='v', markersize=7, label='sell')
plt.xlabel('Days', fontsize=14)
plt.ylabel('Litecoin Price (USD)', fontsize=18)
plt.legend()
plt.show()

plt.plot(df_trade['PnL'], color='k', lw=1., label='Pnl')
plt.plot(df_trade[df_trade['PnL'] > 0].index, df_trade[df_trade['PnL'] > 0].PnL, color='g', lw=0, marker='.')
plt.plot(df_trade[df_trade['PnL'] < 0].index, df_trade[df_trade['PnL'] < 0].PnL, color='r', lw=0, marker='.')
plt.xlabel('Days', fontsize=14)
plt.ylabel('Net Profit from Litecoin Trading (USD)', fontsize=18)
plt.legend()
plt.show()

