# -*- coding: utf-8 -*-
"""Session 3 - Stock Price Predict - Deep Learning Examples.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1G6M1YMeCzifdPa6i9YHdRpKKP4lg-17i

# Deep Learning in Finance

## Multilayer perceptrons for time series forecasting

We will use Pytorch. You can read [here](#https://github.com/christianversloot/machine-learning-articles/blob/main/creating-a-multilayer-perceptron-with-pytorch-and-lightning.md) to see how to use it 




Multilayer perceptrons (MLP) are one of the basic architectures of neural networks. At a very high level, they consist of three components:

- The input layer: A vector of features.
- The hidden layers: Each hidden layer consists of N neurons. The output layer: Output of the network; depends on the task (regression/classification).

The input of each hidden layer is first transformed linearly (multiplication by weights and adding the bias term) and then non-linearly (by applying activation functions such as ReLU). Thanks to the non-linear activation, the network is able to model complex, non-linear relationships between the features and the target.
A multilayer perceptron contains multiple hidden layers (also called dense layers or fully connected layers) stacked against each other. The following diagram presents a network with a single hidden layer and an MLP with two layers:
![image.png](data:image/png;base64,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)
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
# %config InlineBackend.figure_format = 'retina'

import matplotlib.pyplot as plt
import warnings

plt.style.use('seaborn')
plt.rcParams['figure.figsize'] = [12, 8]
plt.rcParams['figure.dpi'] = 300
warnings.simplefilter(action='ignore', category=FutureWarning)

"""1. Import the libraries:"""

try:
    import yfinance
    print("module 'yfinance' is installed")
except ModuleNotFoundError:
    print("module 'yfinance' is not installed")
    !pip install yfinance

import yfinance as yf
import numpy as np

import torch
import torch.optim as optim
import torch.nn as nn
import torch.nn.functional as F
from torch.utils.data import (Dataset, TensorDataset, 
                              DataLoader, Subset)

from sklearn.metrics import mean_squared_error

print(torch.__version__)

device = 'cuda' if torch.cuda.is_available() else 'cpu'

"""2. Define parameters:"""

# data MCD
TICKER = 'MCD'
START_DATE = '2010-01-02'
END_DATE = '2021-12-31'
N_LAGS = 3

# neural network 
VALID_SIZE = 12
BATCH_SIZE = 5
N_EPOCHS = 1000

"""3. Download and prepare the data:"""

df = yf.download(TICKER, 
                 start=START_DATE, 
                 end=END_DATE,
                 progress=False)

df = df.resample('M').last()
prices = df['Adj Close'].values
prices.shape

fig, ax = plt.subplots()

ax.plot(df.index, prices)
ax.set(title=f"{TICKER}'s Stock price", 
       xlabel='Time', 
       ylabel='Price ($)');

"""4. Define a function for transforming time series into a dataset for the MLP:"""

def create_input_data(series, n_lags=1):
    '''
    Function for transforming time series into input acceptable by a multilayer perceptron.
    
    Parameters
    ----------
    series : np.array
        The time series to be transformed
    n_lags : int
        The number of lagged observations to consider as features

    Returns
    -------
    X : np.array
        Array of features
    y : np.array
        Array of target
    '''
    X, y = [], []

    for step in range(len(series) - n_lags):
        end_step = step + n_lags
        X.append(series[step:end_step])
        y.append(series[end_step])
    return np.array(X), np.array(y)

prices.round(2)

"""5. Transform the considered time series into input for the MLP:"""

X, y = create_input_data(prices, N_LAGS)

X_tensor = torch.from_numpy(X).float()
y_tensor = torch.from_numpy(y).float().unsqueeze(dim=1)

X_tensor

y_tensor

"""6. Create training and validation sets:"""

valid_ind = len(X) - VALID_SIZE

dataset = TensorDataset(X_tensor, y_tensor)

train_dataset = Subset(dataset, list(range(valid_ind)))
valid_dataset = Subset(dataset, list(range(valid_ind, len(X))))

train_loader = DataLoader(dataset=train_dataset,
                          batch_size=BATCH_SIZE)
valid_loader = DataLoader(dataset=valid_dataset, 
                          batch_size=BATCH_SIZE)

"""Inspect the observations from the first batch (BATCH_SIZE=5):"""

next(iter(train_loader))[0]

next(iter(train_loader))[1]

"""Check the size of the datasets:"""

print(f'Size of datasets - training: {len(train_loader.dataset)} | validation: {len(valid_loader.dataset)}')

"""7. Use naive forecast as a benchmark and evaluate the performance:"""

naive_pred = prices[len(prices) - VALID_SIZE - 1:-1]
y_valid = prices[len(prices) - VALID_SIZE:]

naive_mse = mean_squared_error(y_valid, naive_pred)
naive_rmse = np.sqrt(naive_mse)
print(f"Naive forecast - MSE: {naive_mse:.2f}, RMSE: {naive_rmse:.2f}")

"""## Testing Linear Regression"""

from sklearn.linear_model import LinearRegression

X_train = X[:valid_ind, ]
y_train = y[:valid_ind]

X_valid = X[valid_ind:, ]
y_valid = y[valid_ind:]

lin_reg = LinearRegression()
lin_reg.fit(X_train, y_train)

y_pred = lin_reg.predict(X_valid)
lr_mse = mean_squared_error(y_valid, y_pred)
lr_rmse = np.sqrt(lr_mse)
print(f"Linear Regression's forecast - MSE: {lr_mse:.2f}, RMSE: {lr_rmse:.2f}")
print(f"Linear Regression's coefficients: {lin_reg.coef_}")

fig, ax = plt.subplots()

ax.plot(y_valid, color='blue', label='Actual')
ax.plot(y_pred, color='red', label='Prediction')

ax.set(title="Linear Regression's Forecasts", 
       xlabel='Time', 
       ylabel='Price ($)')
ax.legend();

"""8. Define the network's architecture:

### we choose the ReLU (Rectified Linear Unit) activation function
$$ f(x= max(0,x)$$
"""

class MLP(nn.Module):
   
    def __init__(self, input_size):
        super(MLP, self).__init__()
        self.linear1 = nn.Linear(input_size, 8)
        self.linear2 = nn.Linear(8, 4)
        self.linear3 = nn.Linear(4, 1)
        self.dropout = nn.Dropout(p=0.2)
    
    def forward(self, x):
        x = self.linear1(x)
        x = F.relu(x)
        x = self.dropout(x)
        x = self.linear2(x)
        x = F.relu(x)
        x = self.dropout(x)
        x = self.linear3(x)
        return x

"""9. Instantiate the model, the loss function and the optimizer:"""

# set seed for reproducibility
torch.manual_seed(42)

model = MLP(N_LAGS).to(device) 
loss_fn = nn.MSELoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

model

"""10. Train the network:"""

PRINT_EVERY = 50
train_losses, valid_losses = [], []

for epoch in range(N_EPOCHS):
    running_loss_train = 0
    running_loss_valid = 0

    model.train()
    
    for x_batch, y_batch in train_loader:
        
        optimizer.zero_grad()
        
        x_batch = x_batch.to(device)
        y_batch = y_batch.to(device)
        y_hat = model(x_batch)
        loss = loss_fn(y_batch, y_hat)
        loss.backward()
        optimizer.step()
        running_loss_train += loss.item() * x_batch.size(0)
        
    epoch_loss_train = running_loss_train / len(train_loader.dataset)
    train_losses.append(epoch_loss_train)

    with torch.no_grad():
        
        model.eval()
        
        for x_val, y_val in valid_loader:
            x_val = x_val.to(device)
            y_val = y_val.to(device)
            y_hat = model(x_val)
            loss = loss_fn(y_val, y_hat)
            running_loss_valid += loss.item() * x_val.size(0)
            
        epoch_loss_valid = running_loss_valid / len(valid_loader.dataset)
            
        if epoch > 0 and epoch_loss_valid < min(valid_losses):
            best_epoch = epoch
            torch.save(model.state_dict(), './mlp_checkpoint.pth')
            
        valid_losses.append(epoch_loss_valid)

    if epoch % PRINT_EVERY == 0:
        print(f"<{epoch}> - Train. loss: {epoch_loss_train:.2f} \t Valid. loss: {epoch_loss_valid:.2f}")
        
print(f'Lowest loss recorded in epoch: {best_epoch}')

"""11. Plot the losses over epochs:"""

train_losses = np.array(train_losses)
valid_losses = np.array(valid_losses)

fig, ax = plt.subplots(figsize=(10,6))

ax.plot(train_losses, color='blue', label='Training loss')
ax.plot(valid_losses, color='red', label='Validation loss')

ax.set(title='Loss over epochs', 
       xlabel='Epoch', 
       ylabel='Loss')
ax.legend()

plt.tight_layout()
plt.show()

"""In the plot, we can see that after the initial drop (caused by randomly initialized weights), both the training loss and validation loss do not seem to have any visibly decreases over epochs.

12. Load the best model (with the lowest validation loss):
"""

state_dict = torch.load('mlp_checkpoint.pth')
model.load_state_dict(state_dict)

"""13. Obtain the predictions:"""

y_pred, y_valid= [], []

with torch.no_grad():

    model.eval()
    
    for x_val, y_val in valid_loader:
        x_val = x_val.to(device)    
        y_pred.append(model(x_val))
        y_valid.append(y_val)
        
y_pred = torch.cat(y_pred).numpy().flatten()
y_valid = torch.cat(y_valid).numpy().flatten()

"""14. Evaluate the predictions:"""

mlp_mse = mean_squared_error(y_valid, y_pred)
mlp_rmse = np.sqrt(mlp_mse)
print(f"MLP's forecast - MSE: {mlp_mse:.2f}, RMSE: {mlp_rmse:.2f}")

fig, ax = plt.subplots()

ax.plot(y_valid, color='blue', label= 'True')
ax.plot(y_pred, color='red', label='Prediction')

ax.set(title="Multilayer Perceptron's Forecasts", 
       xlabel='Time', 
       ylabel='Price ($)')
ax.legend()

plt.tight_layout()
plt.show()

"""# A sequential approach to defining the network's architecture
Multivariate setting: We can use the multilayer perceptron in the multivariate setting. Two types of possible cases are:
- Multiple input series: Multiple time series are used to predict the future value(s) of a single time series.
- Multiple parallel series: Multiple time series are used to predict future value(s) of multiple time series simultaneously.

A sequential approach to defining the network's architecture: We can also define the network's architecture using nn.Sequential, which might be similar to anyone who worked with Keras before. The idea is that the input tensor is sequentially passed through the specified layers.

In the following, we define the same network as we have already used before
"""

model = nn.Sequential(
    nn.Linear(3, 8),
    nn.ReLU(),
    nn.Dropout(0.2),
    nn.Linear(8, 4),
    nn.ReLU(),
    nn.Dropout(0.2),
    nn.Linear(4, 1)
)

model

"""#### Estimating neural networks using `scikit-learn`

1. Import the libraries:
"""

from sklearn.neural_network import MLPRegressor

"""2. Define the MLP using scikit-learn:"""

mlp = MLPRegressor(hidden_layer_sizes=(8, 4,), 
                   learning_rate='constant',
                   batch_size=5,
                   max_iter=1000,
                   random_state=42)

"""3. Split the data into training and test set:"""

valid_ind = len(X) - VALID_SIZE

X_train = X[:valid_ind, ]
y_train = y[:valid_ind]

X_valid = X[valid_ind:, ]
y_valid = y[valid_ind:]

"""4. Train the MLP:"""

mlp.fit(X_train, y_train)

"""5. Plot the loss function over epochs:"""

plt.plot(mlp.loss_curve_)

"""6. Obtain the predictions:"""

y_pred = mlp.predict(X_valid)

"""7. Evaluate the predictions and plot them versus the observed values:"""

sk_mlp_mse = mean_squared_error(y_valid, y_pred)
sk_mlp_rmse = np.sqrt(sk_mlp_mse)
print(f"Scikit-Learn MLP's forecast - MSE: {sk_mlp_mse:.2f}, RMSE: {sk_mlp_rmse:.2f}")

fig, ax = plt.subplots()

ax.plot(y_valid, color='blue', label='Actual')
ax.plot(y_pred, color='red', label='Prediction')

ax.set(title="sklearn MLP's Forecasts", 
       xlabel='Time', 
       ylabel='Price ($)')
ax.legend();

"""### Multi-period forecast

Multi-period forecast: Lastly, we can also use the multilayer perceptron to forecast more than one timestep ahead. To do so, we need to appropriately prepare the input data and slightly modify the network's architecture to account for more than one output.

1. Define a modified function for creating a dataset for the MLP:
"""

def create_input_data(series, n_lags=1, n_leads=1):
    '''
    Function for transforming time series into input acceptable by a multilayer perceptron.
    
    Parameters
    ----------
    series : np.array
        The time series to be transformed
    n_lags : int
        The number of lagged observations to consider as features
    n_leads : int
        The number of future periods we want to forecast for
        
    Returns
    -------
    X : np.array
        Array of features
    y : np.array
        Array of target
    '''
    X, y = [], []

    for step in range(len(series) - n_lags - n_leads + 1):
        end_step = step + n_lags
        forward_end = end_step + n_leads
        X.append(series[step:end_step])
        y.append(series[end_step:forward_end])
    return np.array(X), np.array(y)

"""2. Create features and target from the time series of prices:"""

# parameters for the dataset
N_LAGS = 3
N_FUTURE = 2

X, y = create_input_data(prices, N_LAGS, N_FUTURE)

X_tensor = torch.from_numpy(X).float()
y_tensor = torch.from_numpy(y).float()

"""3. Create training and validation sets:"""

dataset = TensorDataset(X_tensor, y_tensor)

valid_ind = len(X) - VALID_SIZE + (N_FUTURE - 1)

train_dataset = Subset(dataset, list(range(valid_ind)))
valid_dataset = Subset(dataset, list(range(valid_ind, len(X))))

train_loader = DataLoader(dataset=train_dataset, 
                          batch_size=BATCH_SIZE)
valid_loader = DataLoader(dataset=valid_dataset, 
                          batch_size=BATCH_SIZE)

"""4. Define the MLP for multi-period forecasting:"""

class MLP(nn.Module):
    
    def __init__(self, input_size, output_size):
        super(MLP, self).__init__()
        self.linear1 = nn.Linear(input_size, 16)
        self.linear2 = nn.Linear(16, 8)
        self.linear3 = nn.Linear(8, output_size)
        self.dropout = nn.Dropout(p=0.2)
    
    def forward(self, x):
        x = self.linear1(x)
        x = F.relu(x)
        x = self.dropout(x)
        x = self.linear2(x)
        x = F.relu(x)
        x = self.dropout(x)
        x = self.linear3(x)
        return x

"""5. Instantiate the model, the loss function and the optimizer:"""

# set seed for reproducibility
torch.manual_seed(42)

model = MLP(N_LAGS, N_FUTURE).to(device) 
loss_fn = nn.MSELoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

"""6. Train the network:"""

PRINT_EVERY = 50
train_losses, valid_losses = [], []

for epoch in range(N_EPOCHS):
    running_loss_train = 0
    running_loss_valid = 0

    model.train()
    
    for x_batch, y_batch in train_loader:
        
        optimizer.zero_grad()
        
        x_batch = x_batch.to(device)
        y_batch = y_batch.to(device)
        y_hat = model(x_batch)
        loss = loss_fn(y_batch, y_hat)
        loss.backward()
        optimizer.step()
        running_loss_train += loss.item() * x_batch.size(0)
        
    epoch_loss_train = running_loss_train / len(train_loader.dataset)
    train_losses.append(epoch_loss_train)

    with torch.no_grad():
        
        model.eval()
        
        for x_val, y_val in valid_loader:
            x_val = x_val.to(device)
            y_val = y_val.to(device)
            y_hat = model(x_val)
            loss = loss_fn(y_val, y_hat)
            running_loss_valid += loss.item() * x_val.size(0)
            
        epoch_loss_valid = running_loss_valid / len(valid_loader.dataset)
            
        if epoch > 0 and epoch_loss_valid < min(valid_losses):
            best_epoch = epoch
            torch.save(model.state_dict(), './mlp_checkpoint_2.pth')
            
        valid_losses.append(epoch_loss_valid)

    if epoch % PRINT_EVERY == 0:
        print(f"<{epoch}> - Train. loss: {epoch_loss_train:.2f} \t Valid. loss: {epoch_loss_valid:.2f}")
        
print(f'Lowest loss recorded in epoch: {best_epoch}')

"""7. Plot the training and validation losses:"""

train_losses = np.array(train_losses)
valid_losses = np.array(valid_losses)

fig, ax = plt.subplots()

ax.plot(train_losses, color='blue', label='Training loss')
ax.plot(valid_losses, color='red', label='Validation loss')

ax.set(title="Loss over epochs", 
       xlabel='Epoch', 
       ylabel='Loss')
ax.legend();

"""8. Load the best model (with the lowest validation loss):"""

state_dict = torch.load('mlp_checkpoint_2.pth')
model.load_state_dict(state_dict)

"""9. Obtain predictions:"""

y_pred = []

with torch.no_grad():
    
    model.eval()
        
    for x_val, y_val in valid_loader:
        x_val = x_val.to(device)
        yhat = model(x_val)
        y_pred.append(yhat)
               
y_pred = torch.cat(y_pred).numpy()

"""10. Plot the predictions:"""

fig, ax = plt.subplots()

ax.plot(y_valid, color='blue', label='Actual')

for i in range(len(y_pred)):
    if i == 0:
        ax.plot(np.array([i, i + 1]), y_pred[i], color='red', label='Prediction')
    else:
        ax.plot(np.array([i, i + 1]), y_pred[i], color='red')

ax.set(title="MLP's Multi-period Forecasts", 
       xlabel='Time', 
       ylabel='Price ($)')
ax.legend()

plt.tight_layout()
plt.show()

"""# Convolutional neural networks for time series forecasting
Convolutional neural networks (CNN) were developed and remained very popular in the image classification domain. However, they can also be applied to 1-dimensional problems, such as predicting the next value in the sequence, be it a time series or the next word in a sentence.
In the following diagram, we present a simplified schema of a 1D CNN:
![image.png](data:image/png;base64,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)

Based on the preceding diagram, we briefly describe the elements of a typical CNN architecture:
- Convolutional layer: The goal of this layer is to apply convolutional filtering to extract potential features.
- Pooling layer: This layer reduces the size of the image or series while preserving the important characteristics identified by the convolutional layer.
- Fully connected layer: Usually, there are a few fully connected layers at the end of the network to map the features extracted by the network to classes or values.

1. Import the libraries:
"""

import yfinance as yf
import numpy as np
import os
import random

import torch
import torch.optim as optim
import torch.nn as nn
from torch.utils.data import Dataset, TensorDataset, DataLoader, Subset
from collections import OrderedDict

from sklearn.metrics import mean_squared_error

print(torch.__version__)

device = 'cuda' if torch.cuda.is_available() else 'cpu'

"""2. Create some utility functions"""

import matplotlib.pyplot as plt
import seaborn as sns
from fastai import *
from fastai.tabular import *
from sklearn import metrics
import numpy as np
import os
import random
import torch

def performance_evaluation_report(model, show_plot=False, labels=None, show_pr_curve=False):
    '''
    Function for creating a performance report of a classification model.
    
    Parameters
    ----------
    model : fastai Learner
        A trained model for Tabular data
    show_plot : bool
        Flag whether to show the plot
    labels : list
        List with the class names.
    show_pr_curve : bool
        Flag whether to also show the PR-curve. For this to take effect, 
        show_plot must be True.
        
    Return
    ------
    stats : pd.Series
        A series with the most important evaluation metrics
    '''

    preds_valid, y_test = model.get_preds(ds_type=DatasetType.Valid)
    y_pred = preds_valid.argmax(dim=-1)
    y_pred_prob = preds_valid.numpy()[:, 1]

    cm = metrics.confusion_matrix(y_test, y_pred)
    tn, fp, fn, tp = cm.ravel()

    precision = metrics.precision_score(y_test, y_pred),
    recall = metrics.recall_score(y_test, y_pred),

    fpr, tpr, threshold = metrics.roc_curve(y_test, y_pred_prob)
    roc_auc = metrics.auc(fpr, tpr)

    precision_vec, recall_vec, thresholds = metrics.precision_recall_curve(
        y_test, y_pred_prob)
    pr_auc = metrics.auc(recall_vec, precision_vec)

    if show_plot:

        if labels is None:
            labels = ['Negative', 'Positive']

        N_SUBPLOTS = 3 if show_pr_curve else 2
        PLOT_WIDTH = 15 if show_pr_curve else 12
        PLOT_HEIGHT = 5 if show_pr_curve else 6

        fig, ax = plt.subplots(
            1, N_SUBPLOTS, figsize=(PLOT_WIDTH, PLOT_HEIGHT))
        fig.suptitle('Performance Evaluation', fontsize=16)

        sns.heatmap(cm, annot=True, fmt="d", linewidths=.5, cmap='BuGn_r', square=True, cbar=False, ax=ax[0],
                    annot_kws={"ha": 'center', "va": 'center'})
        ax[0].set(xlabel='Predicted label',
                  ylabel='Actual label', title='Confusion Matrix')
        ax[0].xaxis.set_ticklabels(labels)
        ax[0].yaxis.set_ticklabels(labels)

        ax[1].plot(fpr, tpr, 'b-', label=f'ROC-AUC = {roc_auc:.2f}')
        ax[1].set(xlabel='False Positive Rate',
                  ylabel='True Positive Rate', title='ROC Curve')
        ax[1].plot(fp/(fp+tn), tp/(tp+fn), 'ro',
                   markersize=8, label='Decision Point')
        ax[1].plot([0, 1], [0, 1], 'r--')
        ax[1].legend(loc='lower right')

        if show_pr_curve:

            ax[2].plot(recall_vec, precision_vec,
                       label=f'PR-AUC = {pr_auc:.2f}')
            ax[2].plot(recall, precision, 'ro',
                       markersize=8, label='Decision Point')
            ax[2].set(xlabel='Recall', ylabel='Precision',
                      title='Precision-Recall Curve')
            ax[2].legend()

    stats = {'accuracy': metrics.accuracy_score(y_test, y_pred),
             'precision': metrics.precision_score(y_test, y_pred),
             'recall': metrics.recall_score(y_test, y_pred),
             'specificity': (tn / (tn + fp)),
             'f1_score': metrics.f1_score(y_test, y_pred),
             'cohens_kappa': metrics.cohen_kappa_score(y_test, y_pred),
             'roc_auc': roc_auc,
             'pr_auc': pr_auc}

    return stats


def create_input_data(series, n_lags=1, n_leads=1):
    '''
    Function for transforming time series into input acceptable by a multilayer perceptron.
    
    Parameters
    ----------
    series : np.array
        The time series to be transformed
    n_lags : int
        The number of lagged observations to consider as features
    n_leads : int
        The number of future periods we want to forecast for
        
    Returns
    -------
    X : np.array
        Array of features
    y : np.array
        Array of target
    '''
    X = []
    y = []
    for step in range(len(series) - n_lags - n_leads + 1):
        end_step = step + n_lags
        forward_end = end_step + n_leads
        X.append(series[step:end_step])
        y.append(series[end_step:forward_end])
    return np.array(X), np.array(y)

# custom function for reproducibility
def custom_set_seed(seed):
    torch.manual_seed(seed)
    torch.cuda.manual_seed_all(seed)
    torch.backends.cudnn.deterministic = True
    torch.backends.cudnn.benchmark = False
    np.random.seed(seed)
    random.seed(seed)
    os.environ['PYTHONHASHSEED'] = str(seed)

"""3. Define the parameters:"""

# data
TICKER = 'INTC'
START_DATE = '2010-01-02'
END_DATE = '2021-12-31'
VALID_START = '2021-07-01'

N_LAGS = 12  #use the previous 12 days price to forecast the next day price

# neural network 
BATCH_SIZE = 5
N_EPOCHS = 2000

df = yf.download(TICKER, 
                 start=START_DATE, 
                 end=END_DATE,
                 progress=False)

"""4. Download and prepare the data: (data should be in form of a numpy array"""

df = yf.download(TICKER, 
                 start=START_DATE, 
                 end=END_DATE,
                 progress=False)
df = df.resample('W-MON').last()
valid_size = df.loc[VALID_START:END_DATE].shape[0]
prices = df['Adj Close'].values

type(prices)

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
# %matplotlib inline

fig, ax = plt.subplots()

ax.plot(df.index, prices)
ax.set(title=f"{TICKER}'s Stock price", xlabel='Time', ylabel='Price ($)');

"""5. Transform the time series into input for the CNN:"""

X, y = create_input_data(prices, N_LAGS)
#X=torch.from_numpy(X)
#y=torch.from_numpy(y)

X[0:2], y[0:2]

"""6. Obtain the naïve forecast:"""

naive_pred = torch.from_numpy(prices[len(prices) - valid_size - 1:-1])

y_valid = torch.from_numpy(prices[len(prices) - valid_size:])

naive_mse = mean_squared_error(y_valid, naive_pred)
naive_rmse = np.sqrt(naive_mse)
print(f"Naive forecast - MSE: {naive_mse:.2f}, RMSE: {naive_rmse:.2f}")

"""7. Prepare the `DataLoader` objects:"""

# set seed for reproducibility
custom_set_seed(42)

valid_ind = len(X) - valid_size

X_tensor = torch.from_numpy(X).float()
y_tensor = torch.from_numpy(y).float().unsqueeze(dim=1)

dataset = TensorDataset(X_tensor, y_tensor)

train_dataset = Subset(dataset, list(range(valid_ind)))
valid_dataset = Subset(dataset, list(range(valid_ind, len(X))))

train_loader = DataLoader(dataset=train_dataset, 
                          batch_size=BATCH_SIZE)
valid_loader = DataLoader(dataset=valid_dataset, 
                          batch_size=BATCH_SIZE)

"""Check the size of the datasets:"""

print(f'Size of datasets - training: {len(train_loader.dataset)} | validation: {len(valid_loader.dataset)}')

"""8. Define the CNN's architecture:"""

class Flatten(nn.Module):
    def forward(self, x):
        return x.view(x.size()[0], -1)

model = nn.Sequential(OrderedDict([
    ('conv_1', nn.Conv1d(1, 32, 3, padding=1)),
    ('max_pool_1', nn.MaxPool1d(2)),
    ('relu_1', nn.ReLU()),
    ('flatten', Flatten()),
    ('fc_1', nn.Linear(192, 50)),
    ('relu_2', nn.ReLU()),
    ('dropout_1', nn.Dropout(0.4)),
    ('fc_2', nn.Linear(50, 1))
]))

print(model)

"""9. Instantiate the model, the loss function and the optimizer:"""

model = model.to(device)
loss_fn = nn.MSELoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

"""10. Train the network:"""

PRINT_EVERY = 50
train_losses, valid_losses = [], []

for epoch in range(N_EPOCHS):
    running_loss_train = 0
    running_loss_valid = 0

    model.train()
    
    for x_batch, y_batch in train_loader:
        
        optimizer.zero_grad()
        
        x_batch = x_batch.to(device)
        x_batch = x_batch.view(x_batch.shape[0], 1, N_LAGS)
        y_batch = y_batch.to(device)
        y_batch = y_batch.view(y_batch.shape[0], 1, 1)
        y_hat = model(x_batch).view(y_batch.shape[0], 1, 1)
        loss = torch.sqrt(loss_fn(y_batch, y_hat))
        loss.backward()
        optimizer.step()
        running_loss_train += loss.item() * x_batch.size(0)
        
    epoch_loss_train = running_loss_train / len(train_loader.dataset)
    train_losses.append(epoch_loss_train)

    with torch.no_grad():
        model.eval()
        for x_val, y_val in valid_loader:
            x_val = x_val.to(device)
            x_val = x_val.view(x_val.shape[0], 1, N_LAGS)
            y_val = y_val.to(device)
            y_val = y_val.view(y_val.shape[0], 1, 1)
            y_hat = model(x_val).view(y_val.shape[0], 1, 1)
            loss = torch.sqrt(loss_fn(y_val, y_hat))
            running_loss_valid += loss.item() * x_val.size(0)
            
        epoch_loss_valid = running_loss_valid / len(valid_loader.dataset)
            
        if epoch > 0 and epoch_loss_valid < min(valid_losses):
            best_epoch = epoch
            torch.save(model.state_dict(), './cnn_checkpoint.pth')
            
        valid_losses.append(epoch_loss_valid)

    if epoch % PRINT_EVERY == 0:
        print(f"<{epoch}> - Train. loss: {epoch_loss_train:.6f} \t Valid. loss: {epoch_loss_valid:.6f}")
        
print(f'Lowest loss recorded in epoch: {best_epoch}')

"""11. Plot the losses over epochs:"""

train_losses = np.array(train_losses)
valid_losses = np.array(valid_losses)

fig, ax = plt.subplots()

ax.plot(train_losses, color='blue', label='Training loss')
ax.plot(valid_losses, color='red', label='Validation loss')

ax.set(title="Loss over epochs", 
       xlabel='Epoch', 
       ylabel='Loss')
ax.legend()

plt.tight_layout()
plt.show()

"""12. Load the best model (with the lowest validation loss):"""

state_dict = torch.load('cnn_checkpoint.pth')
model.load_state_dict(state_dict)

"""13. Obtain the predictions:"""

y_pred, y_valid = [], []

with torch.no_grad():
    
    model.eval()
        
    for x_val, y_val in valid_loader:
        x_val = x_val.to(device)
        x_val = x_val.view(x_val.shape[0], 1, N_LAGS)
        y_pred.append(model(x_val))
        y_valid.append(y_val)
        
y_pred = torch.cat(y_pred).numpy().flatten()
y_valid = torch.cat(y_valid).numpy().flatten()

"""14. Evaluate the predictions:"""

y_valid_torch=torch.from_numpy(y_valid)
y_pred_torch=torch.from_numpy(y_pred)

cnn_mse = mean_squared_error(y_valid_torch, y_pred_torch)
cnn_rmse = np.sqrt(cnn_mse)
print(f"CNN's forecast - MSE: {cnn_mse:.2f}, RMSE: {cnn_rmse:.2f}")

fig, ax = plt.subplots()

ax.plot(y_valid, color='blue', label='Actual')
ax.plot(y_pred, color='red', label='Prediction')
#ax.plot(naive_pred, color='green', label='Naïve')

ax.set(title="CNN's Forecasts", 
       xlabel='Time', 
       ylabel='Price ($)')
ax.legend()

plt.tight_layout()
plt.show()

"""## Recurrent neural networks for time series forecasting
Recurrent Neural Networks (RNNs) are a special type of neural network designed to work with sequential data. They are popular for time series forecasting as well as for solving NLP problems such as machine translation, text generation, and speech recognition. There are numerous extensions of the RNNs, such as Long-Short Term Memory (LSTM) networks and Gated Recurrent Unit (GRU) networks, which are currently part of some of the state-of-the-art architectures. However, it is good to be familiar with the original vanilla RNN. The following diagram presents the typical RNN schema:
![image.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAngAAAFVCAIAAADzLwUYAAAgAElEQVR4nOzddVwU+RsH8GeLlAbpkpDFQMUADBRBRAUVsbsLO844FeM8u0XPxs4TFTtAFAwURSmRkE5pWNia3x9zx89D7xTY2WHxef/ha3eZme9nx5l9Jr/DIAgCEEIIIUQNJt0BEEIIoaYMCy1CCCFEISy0CCGEEIWw0CKEEEIUwkKLEEIIUQgLLUIIIUQhNt0BEEJNi5gX9+Bq8NuPiZmFcjqmpjYdh3t115RjfGvIkmfBb5o7ORvmv9t37i7TbsjCvhb1abH4xenDj5s5Dx7U2aqB2RGiAu7RIoQkKebyzg59R89e98ebD/HXdq+YPbTX/D/ufntQYczCcVNO54sEeYknT5669CKrnk0WPTmwavmV8Lh6Z0aIUrhHixCSpAe3b1Sp2o6/8PC4ux7x8eTQ3jNuX78Lc/oUPLt457OORW7Yxcj8LqPmjHBQDTsblF9V9vbsiYyBjrNmzZJvawYA/OTggNM335Uq95m2yNNalZ8Vd/RqiKaDR9W9g5ECK++p45312QBl53dsCU6u1LXpOnPSIH26vzJC/w33aBFCElT9+k2iyrDNe931GABMqzEHlrqUx70CECed/33ahKn740Rq7Ox5Pl5rn+eVlpTyhaKykuLPsWELfOdOOv0u/uYes7aDfntWJl8WM7aDZduZAZ9in8739Z0yfOyrvKI7W2f07NA3LC9jSy/b1VffGakW3vUbNWbdCbq/MkLfgYUWISRB4soqgZq+keJfb5maBjocPo98o9im34lta/12n/cxK/M7keYxc5RhM/XuM+e31maRAzy6cSnbYOjBwIPb/HdNNqp+f3xtaJoQgFXuumLn9t/H26rA5/iMEp15V8M2DOuc/jEhr1qQm1NAy/dE6MdhoUUISRBTU1UhIzaq/K+34ozoRJ6SOvlGUUmVDQDAVFaSgyre1yNXVVSBqlZzNgMYStpqLBCW83gEAENdSYkBjL9+rYS5u7ycJvy6512ZnqmOvBS+EkINhOdoEUISJO8xoPfRTcv7+ubM79miLPqm/56X7YZuJv+WHxt6PuSlhfhDaEKF85hOADkMghd3736WvpgcoGWbtoxrN7cf6zXdIO1KXDmYD2llVPs3Spzy6sCzLPdFexZ0Kvl9zi2pfjmE6gX3aBFCkjT4lx2HhpllBqwcOXTY9I3X8jvOOr5pDvknVchfO7hrl97jstuMujbRDOTadGmldGHG+EdpQnKA/tN/Wdyu/MaMfs4DZiXbjj9x92Q71dq/UUzzjnN6GAdtme+5LaVFK82C7Dypfj2E6o6Bj8lDCEkcUZbx/O0nVSv7Vnrk6Vrhi3n2ntE908/Peh1bYNGxi67yvx1OExUnRcUUK3S2t+X86+QroiITW3SwU6EgOUISh4UWISQFwsgVLqPiu8X8uZFFdxSEpAwLLUIIIUQhPEeLEPq/ytKiQp6Y7hQINSlYaBFCNXjzB/fdnyGqeR95ZqOmjvXo2xWSbyr/qJee9ujd135o4E/Xlq/dX1jvtorjf5s/58qLZBAkbnU26rnAv95TQqgesNAihP72ZsetSqv5Vv+/CEnI5xeVlJfxKWiLqC4vLeLzBT80bFrokYCrpfXd0yZKUk8f2P8kJhNAxKuoKONR8X0Q+ld4Hy1CCAAAeK/WzdjJddmiAgCfI1cuWnf/Q2Fz5b+u4Uh/fWvDhh3R2WWKhq1H/vLbhM46BxZNeKdoxYkJfVsk12HUkqUTe8K72xs27HiXW63X3m3A+GnDFKLGLN+v2ca+IvJhmkCD6z5p2xIv5psL+w6cvxtfZG6vlSsktABEWc9Wrdz6KDabqao/euGq2X10Lyyce6dKpyI5OrVYYO054/BA/ry1N8vziyZN3PIoYCmZp+jjs60bfn/xMa9KXrP9oGkzJnmZpdwf/VVzWiwGAARdOJ8jJK4f/WPX2FUAUPjm5giPwLRCfqshcw8sHcGoFcCjPU3/AajpIhBCiCAEN6aasBkLjj0hiPIbo1vItR78gcdbP7wDcPQ9A0t/7WcNLmufFfP3TO8B+gP+yK+e3kUXbMedT+NdWD0CWJpOR9LIYT7E3nXQYIP+gHtBh+SAAVYjIpNeeOrJg0KLP+OjxxkpgrxJQMTHS2NbKTJg6OajB1z1DFznFPPzQhd3VeQOJPjxa+3VFex8kqqqUv0HNdOxv1clFj9eqG3eO0X0/7R7JjuBUZ9NkcWvTqzkMDgw5Xr2o8O1m0vhkwOLP92xkWPMOxpKTly+jXcCryp5V39lPYdnvPTaARCSNDx0jBACAChPSM0XgYJSM+C/e/SqoJVTD2sFBWcXVwBgENUfUvIMxIlHF896GFcCBW/vRfAAWCbDFg0xVuju1ENOVBr+LIIcZuv2M0xFJhS8TcoUALDBZVwbM0sHEyUQVfPTUyLyqsDCs0d7S5+Vo+3kmAxB+sM3hezC94tnrTiVTrBzU8gwlh06t5CXN3HprC4WlH/jxghhfEwqeC6c316tQ68elhwhhF5PExK1mxN8+5YKq44OVgry5q5d1MT88sqwbwZASILw0DFCCAAI4LDYBAAQIBbwRWIAskqRD2wXEwSDo2fTwV6T39KiTU+wNec8BmAwWQwAsVgMAM3kWH8N01HNytjURazE1WDV6qaYEImEBAEMAIIgGEwGAwAIMQHKuib29vbAt9JvrUSmkZPjAAAwmf9I+OVrBqiIRQIADkEAUfPHf/aK/PV3/OfEGQQQ4m8HQEiCcI8WIQQADPUena3kGIVFn0HBaeoQ25irh1b7+2/eFwAABEO5s32L1NAbkSXi8MAjG45H8LXZAKLU3cNHrN23Yoc/v5n12LF9yWEyMj/s2/jbhuMRIqXaPy8M0/bDWmky4k6uXL5unM+2l1VisZzVlAFmaTFxJWJe0rUDv10I+XY6DodRGLdw6dGa9069OpWdnuW1ZOfS5Vvjxeptps5rwWb865djslgAd8+f/fovIpV+PxQAoQbAQosQAgAArmdvK5W03GwAtt2qPzw08tfP9k0CXbJ8jfZd3E749uiy2ZdiiSXH/cdqMwFYFm2NonctOBma2W3Fgd8d5clhNm7Yl2XYa8lxfzulryofS2/14TWeZqyz2zc+MenaSYMNIO+x53Q/jcxlsxduf/x5su+Mb0ZjtO7fXpN39dztmk8Gjp3prFEcun3h9ksvbKfuvrKw9X/8ljGaW3l3Nv0U8eRbf1T5kQAINQT2DIUQIokL767u8XvWg0fH9JjAryjOKhQYGOrI1VQwIa8oN0+k0lxbVRFAOMPB9KHXg5h5OgWVLAMdjZphsnOLNfT1Ff6j7okqsvIqmus3rzlxJRbwcrLyCFVdAw2Ff98t/Tovrygnr5KjbqijVufvWmtK9QuA0I/BQosQ+r/980Z+GnF0q+N3T1UK1wzrGeF6KmiaOR4WQ+i/YaFFCCGEKIQbowihpqCypBB7aUaNExZahFBTEHZijZbHpijR94dESMqw0CKEmgKnrk7az3bNOvoJT4ahxgYLLUJIEgQfFo8Ze/CjgPgcNXtg/35zjuUXphxYMrZ/DyeH7r3HrzoUkiMqT3uzbtoQVyeH7n28l555llOz90lUx/y5Y8Hwvk6OTm7DZ6++ElX5OWn3glF9ezg5dus1bN7vlz7wSpNfLBvdv4djl26uXvOPhJYJy5+d2DB9sKujU/fBs9cdfZmjaOc8xYYf7jfzeSHu1aJGht4eIBFCTUR1uKOe4cyXVeL0+23kGNBu4b1zW5hMNbvtCR+vbpVjcJi+908u84Lm3VdFFN7bOZvJ0ukZkEOOKkq6ZclhgJHH09in7s3lQKXDrr0bmSwN++3RH6/tlAMO+N6/9Nso0Oq+Prn6xqbJoNDi5PnjmkzWl10rv6oQRsxrJwdy2x9l0TsnEKoF92gRQpRgsZhMcWn87tE73so/Sc0r2dYzMyEZlCD1j6VngmOYoqKQxy/IIQs/ZaQJWOAyuQu38/6LF68EbPQZN//Tk0NTBedX7jolAAL41SwmC4reHhjh80LZ7VNOVFtxbjHB/GfXykIjPQ0mCEuLPtP7xRGqBfs6RghJBJvBIIRCguDzeQQBAM3tnFbOmlbUTDEj5Ljz1vUWUw6MAoKhpMftYK9SbWPStgennQU5pkgkAiDkOWyCEFVVC4Vi8duLm0bMOdx21vyRjh2vBr8TALTrMXjWVM1mChVhR3/9bcOWdTM8AFj/7FqZ7IOR8c8ekhGiHy6RCCFJ4JhpKZYHbVy/Yr1/igAAIC7k+rqDZ28kKfdw7qJcVRATl9qqUyci8cnld8Ufwq6v33w4XKBNjqrbyqaNMlRfWbZizQovz2HDfzkbk51eLmKw2Qrvol4LAQAg5Ooh//N34tXsnDu3ZuQnqbdoacLh/7NrZSI6IVPEVDEyNqZtJiD0LdhhBUJIMp7/uf/Y9Qjdtvb6FYV5Og7zR7a6eyrgdWxyPl/eqF13d29vx2YF186efh2XVMDU7uI1aXhPS+W/OjwUZYddvvQw4l1amXarrm6DfbowE/bv+SP+s7h9Nwd+Rlq5qcvi3uonAk7FpuTx5TW5zj5TfTqXR1y/HvL6bfJnTa5Tr4HerjppY1t1OtN8ysenuyyxI0XUmGChRQg1BZ9u7G4x7sT8+893dJSnOwtC/4CHjhFCTUFMUnLXhXs3YJVFjQ/u0SKEEEIUwj1ahBBCiEJYaBFCCCEKYaFFCCGEKISFFiGEEKIQFlqEEEKIQlhoEUIIIQphoUUIIYQohIUWIYQQohAWWoQQQohCWGgRQvR49OhRdXU13SkQohwWWoQQDZYsWdK7d+/ff/+d7iAIUQ4LLUKIBmfPnqU7AkJSgoUWIUQDFotFdwSEpIRNdwCEmg6xWEx3hEZNKBQKBIKqqqq4uDg2mw0Ap06dMjQ07Ny5c4sWLRQUFFhMFuAj2/8dg8FgMHAGyR58TB5C9VdZWXnw4MFbt25FRkaWlJRgoUVU09bW7tChw+jRo8eNG0d3FvSjsNAiVE9Pnz718fHJzc2lO4js0dHR6d2799SpUzU1NWfOnBkVFcXj8egOJUsYDMagQYN27dplYmJCdxb0fVhoEaqPqqqqTp065ebmDh06tHv37mZmZsrKynje8b+xWCwOh8Nmsw0MDMhDx6SqqqrMzEyhUCgSiWiM1/iJxeKSkpK0tLQ7d+6cPHnS2Ng4PDzcyMiI7lzoO7DQIlQfES8jOnfp/OTJk27dutGdBf10CIJo27ZtdHT0lStXvL296Y6DvgOvOkaoPip5lQBgaWlJdxD0M2IwGOSOrFAopDsL+j4stAghJHvw8mMZgoUWofpQVlbmcrl4UhbRxdTUlMvlqqmp0R0EfR+eo0UIIYQohHu0CCGEEIWw0CKEEEIUwkKLEEIIUQgLLUIIIUQhLLQIIYQQhbDQIoQQQhTCQosQQghRCAstQgghRCEstAghhBCFsNAihBBCFMJCixBCCFEICy1CCCFEISy0CCGEEIWw0CKEEEIUYtMdoJ4qKyvz8/PLysrEYjGLxVJTU9PV1eVwOHTnQk1feXl5Xl4ej8cTiURsNltJSal58+ZKSkp055Jh1dXVeXl5FRUVAoGAwWAoKChoa2urq6vTnQs1HXw+Pz8/v7y8nM/nMxgMOTk5bW1tDQ0NBoMhhdZlrNAGBQUFBARER0d//PhRJBLV+qupqamrq+ukSZMcHByYTNxZRxJDEMT5c+fPnD0TGxubkpJS669MJtPS0rJ169Zjx44dNGgQLQllUW5urr+///Xr1+Pi4qqrq2v9VVdXt2XLlsOGDZsyZYq8vDwtCZGsKy4u9vf3DwwMfP/+fVVVVa2/amtrW1lZeXt7T58+XUVFhcIchCwoKChYtGiRtbV1rfAMBuObBVVPT2/nzp1isZju4EjmpaWlTZo0ycDA4OvF7JvLXosWLQICAuhO3djduXOnU6dOX+9MfHOWqqmpeXp6RkVF0Z0ayZLHjx93797968Oc31zGFBUVXV1dnz9/TlEYBkEQX7faSBQXF1+8eDEkJOT27dvV1dVWVlY9evRo3769vr6+ubm5vr6+iooKk8kUi8VFRUXZ2dm5ubkJCQmvXr2Ki4t78+ZNs2bNOnXqNGnSpCFDhkjn+ABqMgiCuHbt2rFjxx49esRisWxsbHp079HWrq2+vr6ZmZmenp6SkhKTyRSJROXl5Tk5OSkpKdnZ2VFRUY8fP46JidHT03NwcJg8ebK7uzvdX6URefny5bFjx548eZKQkGBubm5ra+vo4Mi15bZo0cLAwEBFRYXD4RAEUcWrys3LTUtLy87OjomJefr0aWxsbFFRUZcuXVx6uYwZO8bS0pLur4IaqaioqOPHj4eGhr5//97IyIjL5To5Odna2lpYWBgaGqqoqMjJyQFAdXV1fn4+uYzFxsaGhYXFxcVlZ2d36NChZ8+e48eNt21lK8lYFBXwhsvJyeFyuWTI8ePHV1RU1Gn0uLi43r17k6Pb2dlFRERQlBM1PVFRUZ06dSIXnsWLFwsFwjqN/uLFCzs7O3J0Dw+PtLQ0inLKEB6Pt3DhQhaLBQAGBgY3btyo6xR2795NHkBWVVW9dOkSFSGRTBMKhBs3biQXEi0trfPnz9d1CsePH1dTUwMAJSUlf39/CR4TbaSF9ty5czo6OgBgYWFx+vTpen/h8PBwExMTAOBwOHfv3pVsSNQkhYSEKCoqAoChoWFISEj9JiIWiy9fvqytrQ0AGhoakZGRkg0pW9LT08nzPkpKShs3buTxePWbTnJy8ogRI8ijUydOnJBsSCTTCgoKyI1jeXn5JUuWFBcX1286ubm5s2bNIrcId+/eLal4ja7Q8ni86dOnA4Curu6BAweEwrrtTHwtNzd3w4YNXC5XVVV1/fr1ZWVlEsmJmp6CgoLNmzerq6tbWlr6+fllZ2c3cIKfPn1avHixgYEBuTCXl5dLJKcMEYlE169ft7a2VlFRGTVq1Lt37xo+zQcPHnTt2lVRUXHu3LmxsbENnyCSaWKxOCQkxM7OTkFBYeDAgS9fvmz4NJ8+feru7q6goDBhwoQXL140fIKNq9Dm5eW1adMGAEaNGlXvzd5vEovFHh4eADBnzhwJThY1GdnZ2Xp6egDg4uIi2cvoqqurO3ToAADW1tYlJaUSnHIjJxQKyWuwDQ0Ns7KyJDvxqVOnAgCbzf7Jjxb85MRisa+vL3msOC4uTrITX7x4MXkCqN5Htmo0okJbWVHZqlUrAOjVqxcVFwwnJCSoq6srKiq+fCGBTR7UxCxatAgAlJWVY2JiJD7x8PBw8lrH3377TeITb7TOnDlD/k6dOXNG4hPPz883NzcHgEGDBkl84khWBAUFkcvY/v37JT7xsrKydu3aAUDPnj0bOKnGUmjFYvGECRMAwM3NLT09naJWUlNTHRwclJWV/fz8BAIBRa0g2cLn8zdt2qSgoDBp0qTExESKWnn9+rWnp6eysvLRo0d/hhvPnj59qqur26pVqytXrlD0fUtKStavX6+oqDhx4sS8vDwqmkCNWXR0tJmZmYmJydGjR0UiERVN8Hi8PXv2NGvWzMvLKykpqd7TaSyFduvWrQAwa9YsqhuKjo4mL6agYisbyaKRI0cCgJeXlxTa6tatGwCsWrVKCm3RKDg4mMPhmJiYVFdXU93WggULyMPyUmgLNR5xcXHq6ura2tr1vu7px61du5a8bKjep34aRaHNyclRUlIyNTWt630U9bN8+XIAGDBggBTaQo3cu3fvyENPN2/elEJzp0+fJq+Bb8L3/FRVVZmamgLAhg0bpNBcbGwsuekcGBgoheZQYyASicjrHpYsWSKF5jIyMpSVlRtyrXujKLTz588HgHPnzkmnObFYvHXLVnl5+UOHDkmnRdRojRgxgsVi+fn5UXToqRY+nz9t2jQAmDlzphSao8WWLVsAoEuXLkVFRdJp8dq1a5qaml26dGn4TQpIJhw+fJg8jNHwWwN+0NOnT42NjVu1alVZWVmP0ekvtKWlpcrKyq6urlJut2fPngAQHh4u5XZR4/Hu3Tsmk7l48WIptzto0CBFRcX8/HwptysdJiYmxsbGde1hpoHu3r0LADt37pRmo4gurVu3VldXz8jIlGajsbGxLBZr3rx59RiX/kK7evVqJpMp/Y5Mye3uXr16Sbld1Hh4eXkpKyuXlkr7lpukpCQ2mz1//nwptysFt2/fBoCjR49Kv2kLCwsDA4P67XAgGRITE8NkMn/99VfpN92hQ4dmzZrV4141mgvtixcvlJWVPTw8pN90eno6+bgGidyPjGROQEAAAEyZMoWW1gcPHqygoBAcHExL6xQpLy83NTVt164dLZdVb9iwgeyu9We4qPunxefzO3bsaGFhUVVVJf3W9+/fDwCurq51PdNE87Pk5s2bV1FR4ePjI/2mjYyMZs+eDQDkNjj6qQiFQvLGWbqeauft7V1VVTVnzhxaWqfI48ePU1NThw0bRsszPIYMGQIAAQEB6enp0m8dSUdERMSrV6+8vb1peXIiuYw9ePDg/fv3dRqRzkKbmJj4/PlzDofTp08fWgL88ssvhoaG9+/fp6V1RKPw8PCCggJtbW3yVL30ubm5KSgoREdHx8TE0BKACk+ePAGAmod5SFnLli179eoFAI8fP6YlAJKC0NBQoG8Z09XVHTduHPy9qP84Ogvts2fPAKBbt25GRka0BFBXV588eXJkZKRIWPsZ8qhpi4iIAICxY8eSV+1Ln66urpubGwA8f/6clgBUCAsLa968ec2Dj6SMwWAsWbIEAF68eEFLACQF4eHhbDa7R48edAVYuXIlGaNOY9FZaLOzs4G+bROSh4cHj8eLehdFYwYkfWmpaQDQt29fGjO4uroCQFZWFo0ZJCstLc3JyYnGZz+7uLgoKSklJyfTFQBRLTU11c7Ojny+Fi2sra3NzMw+ffpUp7HoLLTkneZDhw6lMUOnTp3U1NT+/PNPGjMg6YuLj9PS0nJ2dqYxg4+PD4fDiY2NpTGDBBUXF2dlZQ0ePJjGDPLy8r169fr48SONGRB1RCJRSkqKp6cnvTH69euXlJRUp1HoLLSpqanGxsbkgyp/HFHw6sKB/TdfJgBAYsTd/X9cjeIR9c7AYrEMDQ2b0uE79CPS0tI6d+5cp+spqjKjD+z3978dJwIgEu4d9vcPi89tSAYDAwNLS8vU1NSGTKTxePHihUAgqOtBgujHgfsO3cwXAQiS7h72v/E8roExnJ2dyUNlqOlJTU0tKysjDwXVgZj36vzBU7fJEwqiu2cPXYmpaEgMFxeXvLy8ysrKHx+FzkJbWlpKPpisThiK+Xd+X7L84HUAuPPHOl//J5XsBh2qUlNTwzXzZ1NeXm5oaFinUTjlyZvm+86etz1FKHqxd7Gv74In6fwGxtDX1y8tLW3gRBqJ9PR0Doejo6NTp7ESnwfOmTsnNFVAPPOf7zvn2uu0BsYwMzOrqKiorq5u4HRQI0QesDUzM6/baEx2wa3tE1b7VwMA/4XfovWPKtkNiUE+NqpOR4/pLLRlZWV1/bEDAFB2+3WRS+rzpxnCwvDXma6/zO/Mrrx4/GSCsJ77tWpqavn5+fUbF8mo8vJyY2PjOo3Csuz6S08DZsqN0Jev9l9L5Bv3d++kFn5806IpY6csXPs4W1CPGEZGRuXl5fUYsRFKT09v1qxZXU/Q9nB21RGkvXjx4vrB6x9Br3sPBwAAXvLOnUfqN1/IbpbT0hpasFEjlJaWxmaz9fXrunvG6bN8oXl6xPFMQcm1w8k6nZd1kK+KuHDsZj0PZJKFtk7HougstEKhUElJqe7jsS1m/tqq5N2hZ+cjysy2DTcR5n3w37brUXJeVb1icDgc3P792YhEojpfb8zSmrlmpA2zIPzEkaBMMJ+0hvvp7uBpW0JslnQknvece6aw7jGUlJQEgvpU6EaIx+Ox2XXeUdDs1HOstfKLxwEHb38StZ/obsPbN7JnO2v7Rfsu8+oVo1mzZgBQp8N6SFaQyxj5aOc6YXKnupqV7jz2/Nzh25aursb8/IRr/luOBubWq2aQPx08Xh2WUDoLLYPBEInqdV+NXMcO5uJb6y5Um7VrzaoO+3V0eHzUTM+VD6vrs1NLEASLxapPDCSz6rfsMTqP8rJWCQl5XKzSesQI2+y0rDyFFn28uDbWreBt6PO6L34ikagevxqNE4vFIoi6r4Asg3EDrJIfhLwuk7PyHNmcpWjl0Hvw+H7N5ep5PkgoFAJAPUo+avzquYwBALDt2lkkXF93/k1hO1uu6PHaITvCE24eWvSkPptz5E9HnaoGnSu5kpJSbm79Lidhu/TpFvngiaO7MwvkXQ49dm3d6c+ow/3l67NylpWVqaur1ysGklWKior1OTEvZ7dw5cDPySnNhy5faMUpr6wCtoqWFltRoRmU5GcJ6zy9nJwcGm9UkKzmzZuT/QzXcTym3fxlmgWp+VZDf59hw2Squc9btWaZlyarnj9N5O1Surq69RsdNWa6urrV1dX1u6zBuXdfzusHjytMnHt0YvXd93JDr1bDl552q8/al5GRAQB1usCIzkKrpaVV7zveWrZsxWSpu/ZyaXiMgoIC8pg7+nloaGgkJCTUfTymjtsAQ23zX/w8tZmg2kwBBEU5OcKKyhLQ0Dep+05UYmKitrZ23WM0Rlwut7KysqCgoM5jGvS2MdLqMm/dYC0JHFiKiYlRVlZuMnMVfal1q9YAEB0dXY9xLWystVkscJ7rbtXQPmrIAK1atfrxUegstJqamunp6fU5mxJ7aMovO0TG7o6tVQEAgAnC4tDbkbni+sQoLCw0MzOrz5hIZmloaNT1TjgAceL+8U4OvvF6HSYZsgHA0MxYv/pT0MkH4ZGvwb5nlzoeUBEJRenp6RoaGnWM0Ui1bNkSAOraByzkvx7r5BCUozN/pLFEfozi4+PJh4WgpsfE1ITNZtfn1nPBh2lTF2cz9Lymj1VjAAAwGYzST3Gv8utz7jI2NlZZWeRP+QEAACAASURBVJm8GuAH0VlobWxsxGJxfTqL0Gw9Zdmmm7f8WykwAAAYGvN/mamWll4srvPh+4z0jLy8vAEDBtQ5A5Jl1tbWHz9+/PDhQ11GYqi17Tt6vt+Nw+vJMw1sW/frJ9cOqwrM0/MM3z1crY4Zbt2+VV5ebmNjU8fxGikzMzMtLa3AwMC6jabYvO+YuYfPHBmu9sVmilyr2bNG1eM6SZFI9PDhQwsLi7qPimQAh8MxNja+ceNGncdkanhNXRYQdDdg4F/btao+Kxf0a51SUp+ds1u3btV534yCRwn9KPI5Zb1796Yxw9q1axUUFIQCIY0ZkPRt27YNABYtWkRjBvLBQYcPH6Yxg2R17dpVV1eXxqfUkY9/nzlzJl0BENUGDBjA4XB4PB5dAcgjYcOHD6/TWHTu0ZIbns+fP+fzG3rjf73dunXLxMSExcarjn8u5N2Wd+7coSuASCQin0PSlHa/rK2tc3NzaXxK3bVr1wDAysqKrgCIatbWLQUCQXx8PF0Brly5AgBcLrdOY9FZaO3t7Q0MDCoqKh49ekRLgMDAwJcvX9L1oDREo27duikqKsbExERF0fM8idDQ0MLCQm1tbbqedUMF8pkqDx8+pKX1goKCM2fOAEDXrl1pCYCkoFu3rgAQHBxMS+sVFRW7d+8GAAcHhzqNSGehVVBQWLVqFQDU55h7g4lEojlz5hAEQT6tDP1U9PT0xowZAwA3b96kJUBQUBAALF68uE6XVDRyZEfHdT5NKyG3b98uKSmxsbFpStsuqBZ3d3clJSW6lrFHjx5lZmZqa2vX+aFz1BzH/lF8Pt/d3V1PTy8/P1/KTZNHAExMTEpKSqTcNGoM8vLyrKysuFwun8+XctNFRUVGRkbdu3en8VQTRZYuXaqkpPT27VvpN+3u7t6sWbPHjx9Lv2kkTfv27ZOTk7t37570mx4xYgSHwzl//nxdR6S50BIEUVxcrKSk5OHhIeV2yU0SXC1/ZpGRkQwGY8WKFVJud+jQoQoKCrm5uVJuVwrEYrGhoaGZmZmUtyHIY4mbN2+WZqOILlwuV0NDIycnR5qNJiQksNns+l1qR3+hJf4+eBsdHS21Fj99+qSgoODp6Sm1FlHj1KZNG2Vl5djYWKm1SF6B5ezsLLUWpWzixIkg3Su6q6qqbGxsNDQ0qqurpdYootHixYsBYMiQIVJrUSwWOzs7Kyoq1u/ga6MotA8fPmSxWIMHD5bOjQHBwcGmpqY2NjZFRUVSaA41ZmfPngUAAwODjx8/SqG5N2/eqKmpMZnM27dvS6E5Wrx7905VVZXJZAYFBUmhuYKCAkdHRwBYv369FJpDjUFiYiLZy+bZs2el0FxpaenAgQMbsvnYKAotQRAbNmyQzlZwXFwc2Y37yZMnqW4LyQRvb28AGDx4sBTaIi9xX7p0qRTaotGdO3eYTKaZmZkU7lBfunQpALRo0aKqqorqtlDjERUVpaqq2rx589LSUqrb+u233wBAW1u73vtmjaXQisVisgu3vXv3UtrQ7NmzydWS7AAdobKyMi6Xy+FwHj58SGlDJ06cAIDevXuLRCJKG2oM1q1bBwDjxo2j9DBVdna2pqammpramzdvqGsFNU5kl0eurq6UnjIoKyszMDBgs9m3bt2q90QaS6ElCCI0NFRLS4vBYFB0RUNhYeHcOXMVFRVnz56dl5dHRRNIRhUWFnbv3l1BQWHGjBkFBQUSn35mZqaPjw+TyezXr1/Tu9L4m8Ri8bRp0wDA3t6eissvKisrN27cqK2tbW1tHRMTI/HpI5lAHs+wsrKKiIiQ+MT5fP6+fftMTExMTEzCw8MbMqlGVGgJgsjKyiK7fp00aZLEN1LIHu9mzJgh2cmipiEjI4N85Evfvn0luxMmFAi7dOkCAObm5j/VZQECgYC8s9bExETim7azZs0CACaT+fLlS8lOGckQsVg8ZcoUAGjevHlSUpJkJ758+XLyJtj79+83cFKNq9ASBJGXl2doaAgAHTt2lNS+RUlJyahRowDA0NAwMzNTItNETc+7d+/IvsK9vb0LCwslMs2UlJRu3boBQLt27TIyfrplj8/nkx2DGBsbP3jwQCLTFIlEfn5+LBZLWVn59OnTEpkmkl1isXjZsmXkOdRz585JapoHDx6Ul5dns9lbtmxp+AQbXaElCCImJsbLy0tRUdHKymrPnj2xsbH13sPIzs5etWqVmpoag8GYPn069k2B/lt5ebmvry+TyVRRUVmxYkV6enq9J5WQkDBv3jwFBQV5efnly5dLv1uMRkIsFu/du1ddXZ3BYIwePfrZs2dCYT2vkCopKQ0MDHRxcQEAHx+fhvzvoCbmxIkT5HXI3t7ewcHB9T4gWllZeffuXfJ5bv369YuPj5dIvMZYaElpaWmWlpbknvuMGTPqOuOSkpL69+/PYDAAgMvlPn36lKKcqOmJiIiws7Mjl71Vq1bVdTvvzZs3nTt3Jkfv1auXxI9oyaKysrKZM2eSF/ybmprW41jc4cOHye4qlZWV8ZYB9DU+n7969WoOhwMAurq6gYGBdZ3CuXPnNDU1AUBBQWHbtm0SPIXUeAstQRAJCQlt2rQhf7B0dXWnTZuWkJDw36OIxeI3b96sXLlSS0uLHNHHx+en3ZlA9SYSicjTDQBgYWGxdOnSjIyM746VlJQ0e/bsmgePz549m8ZnxjVCW7ZsIeeMnJzckCFDLly48N0N6KKiom3bttX04a6mpnbt2jXppEWy6NChQ+T2HIvF8vDwOHbs2HdvMCkrKztw4ICLiwu5YyYnJyfxUxIMgqjzw9KliSCI2NjYK1euBAUFJSQkVFRUGBsbGxgYtGjRQk9PT1VVlc1mCwSCoqKi7Ozs3NzcDx8+ZGVlKSoqOjo6enp6durUycHBgcXCp+ChOhOLxS9fvgwMDLx582ZycrJQKDQzM9PX1zc3N9fT01NSUiKXvYqKipycnOTk5KysrPT0dAUFBWdnZ09Pzy5durRt25ZcdVGNtLS0sLCwGzduPHz4MC8vT11d3draukWLFoaGhsrKygoKCmKxmMfj5eXlpaamZmdnJyYmCgQCExOTvn37enl5de3atSk9hgFRITc3Nyws7Pr16/fv38/KylJRUbGysrK0tDQ0NGzWrJmioiJBEDwer6CggFzGPn78yOPxjIyM+vTp4+np2a1bN3K/VoIae6H9EkEQly5dOn36dHR0dEpKytcD6Onpubi4TJw40dnZmTyAgJBEiISiEwEnzp07FxcXl5WV9fUApqamrVq1GjNmzIgRI7C4/qBPnz7t37//5s2bCQkJIpGo1l81NDSsra2HDBkyY8aMmoMECNVJTk7O/v37r1+/HhcXJxAIav1VVVXVwsJi0KBBvrN9NbUkXFy/JEuF9kuZmZnR0dEnTpxgMBju7u6mpqZt27SldE4hREpJSYmNjY2Jibl169bkyZN1dHRatWplbGxMdy4ZlpeX9/79+/z8/K1bt/r6+qqrq7ds2ZLL5eImC5KUwsLC9+/f5+bmbtmyhTy/07Jly1atWpHHmakmq4UWAIRCoa2tbW5u7u3bt52cnOiOg34inz9/7tWrV0ZGRlRUFJZYSVm/fv2aNWsOHzo8ecpkurOgpikgIGDixIm//vor2XOZ1Mhwod2+fTv5DAdjY+OUlBQ8EYukZvTo0eTTCNzc3O7du0d3nKYgLCyMvOGYw+HExcZZWFrQnQg1NampqdbW1nw+HwCCg4PJjselQxp7zVQQCoU7d+4kX6enp7969YrePOjn8fnz54sXL5Kv79+//+zZM3rzNA1r1qwhXwgEAr+1fvSGQU3S2rVrySoLXyxv0iGrhfby5cuZmZk1b8nepRGSgoCAAKFQWPN2zJgxJSUlNOZpAkJDQx8+fFjz9uzZs5GRkTTmQU3P27dvT548WfM2NDQ0ODhYaq3LaqE9dOjQl28PHDhQs6mCEKV279795dvk5ORjx47RFaZpqLWhLBaLA07gpjOSpICAgFpXtktz90wmC21oaGhkZKS7u3vLli01NTVnz56tra09bty4r+8QQEiyDh8+XFRUNHTo0C5duujo6IwZM8bY2DgoKIjuXDIsLS3txo0bTk5OZO/w06ZNs7e3//Pqn4WFhXRHQ01EcXHxlStXOnToMHPmTACYMGFC165db968+enTJyklkGz/F1LA4/G6du364sULgiDc3NwMDAwIgsjLy/Px8fH396c7HWrKEhISunTpEhcXRxDEyJEjzc3Nyc9XrVrVwKdo/cyGDh1KPukzLCwMAFJTUwmCuHz58syZM+mOhpqIOXPmXLhwgSCI3NxcACCfPH3nzh1vb2/pBJC9q47Ly8vl5eXJ/ij69OkTExNTc7K2pKRETU2N1nSoKSspKVFVVSVv7hw1atTz58+Tk5Nr/oTLXj0QBFFWVqaqqgoA4eHhXbt2TU1NNTExAZylSHJqlqW8vDxdXd2HDx+Sj6YoKytTVlaWwq20bKobkLj/6IANV0tEqf9YwHDZqx8Gg0FW2a/hLEWS8m/LktR6HJPJc7QIIYSQrMBCixBCCFEICy1CCCFEISy0CCGEEIWw0CKEEEIUwkKLEEIIUQgLLUIIIUQhLLQIIYQQhbDQIoQQQhTCQosQQghRCAstQgghRKFv93UcFhZ24MABKUeph+jo6JKSkjFjxtAd5PuUlZW3bNmC3bcihNDP5tuFdtSoUWlpaVKOUm9nzpyhO8IPOXHiRHV1Nd0pEEIISdW/Pr1n9OjR+/fvl2aUehg8eHBcXFx8fDzdQb5vzJgx9+7dozsFQgghafvXQisnJ9f4j3Oy2Wwmk9n4cwIA+QBdhBBCPxu8GAohhBCiEBZahBBCiEJYaBFCCCEKYaFFCCGEKISFFiGEEKIQFlqEEEKIQlhoEUIIIQphoUUIIYQohIUWIYQQohAWWoQQQohCWGgRQgghCmGhRQghhCiEhRYhhBCiEBZahBBCiEJYaBFCCCEKYaFFCCGEKISFFiGEEKIQFlqEEEKIQmyKphsXF/fx40eKJl6joKCAz+dfv36d6oYAoFOnTvr6+lJoCDVQQUFBeHg41a1kZWXxeDzpLHtubm6KiopSaOg/3Llzh8/nU9pEfHw8ANy/f19HR4fShgDAysqKy+VS3QqqkwcPHlRWVlLaRElJCQA8e/asvLyc0oYAwNDQ0N7e/q83xLeYmJhMnDjxm3/6QcuWLaP6a0jZxYsXGzJDBg8eLCcn15ApoB909+5duhcWCUtNTaV7phKampp0zwZJWrRoEd1zFNVmZmZG93IhSUOGDKn5alTt0ZIYDIajoyOlTUhBWlpaRkYG3SlQ3bRp00ZFRYXuFA0VFxdXVFREd4r/c3JyojuCBEjhgAeqtya5jFFbaG/evOnh4UFpE1Lg5+e3du1aulOgunn8+LGGhgbdKRoqPDy8a9eudKf4y6pVq9atW0d3CgnQ1dWlOwL6trFjx548eZLuFBJgZWX15Vu8GAohhBCiEBZahBBCiEJYaBFCCCEKYaFFCCGEKISFFiGEEKIQFlqEEEKIQlhoEUIIIQphoUUIIYQohIUWUevdu3cCgYDuFAghRBsstIhamzdvdnZ2rqqqojsIQgjRAwstotyzZ8/27NlDdwqEEKIHtX0dI0QeN/bz8+PxeL6+vlpaWnQnQgghqcI9WkQtDocDAHw+38/Pr02bNjk5OXQnQgghqcJCi6RhyZIlysrK2dnZv/32G91ZEEJIqrDQImngcrlRUVGzZ88+cuTIpEmTYmNj6U6EEEJSgoUWSYmFhcW+ffvmzJlz/Pjxdu3avXnzhu5ECCEkDVhokVT5+fmtW7dOTU1t6NChISEhdMdBCCHKYaFFUqWkpLRq1arY2NiKiopevXrNnz+fIAi6QyGEEIWw0CIa6OjorF69GgB2794dGBhIdxyEEKIQFlpEj2nTph0/fpzL5U6bNu3EiRMikYjuRAghRAkstIgeLBZrwoQJ0dHRRkZGEydO/OOPP+hOhBBClMBCi+jEZDJ///13AFi/fn1+fj7dcRBCSPIaexeM4oSb/oHRFQQAMBgMRjMDmyEjPHXZEHbl8JNU5rCpE1uoMInUB9tv5i2eNUr49srOB1ntR89y1WcRxcmHDl/O1nX0G9ed7i9RZ6dPn24yd5pGRkb+9wB9+/YNDg6eOnUql8udO3fu4sWLlZSUpJPtvxV+eHEkMOTvRY+ly3UcPcCJDfw//9gbI9dh0rhehiwi4+6Rc2+Le42cIf/86O0Uvq3b0AEdzEsTX/1xJVi128TpXbXp/hKNC/E5Yf/RqxUEAACDwWTKN3PsO6hrS31yde44coKrPotIfXDoYmTLPsO7Ea9230vUaec6ro89ALy6dSqowEwWV2ckVaLCIP+jMZVi+GvFlW/p5O7laBPz5GrQs2TVLiOmOxsyRen3D1/ItXIZ041zad/tTD27OaPdWQBJL+9cfJLtOGFcTy2WhFMR32JiYjJx4sRv/ukHLVu2DABu3brVkIkQBCG4PN6ADRqGZlwul2tppMhiq/neLSOI9Z4tAZi+AeEEQQgfztM0cSYIouoPL3lgQJ/tH4SEKPm2FYcBDqsaGIAgiDVr1gDAxYsXGzKRwYMHy8nJ/eDAgwYNkvB/M90CAgL++ytHRkaSnTUuWbKkIfOZIIi7d+8CQGFhYQOnE395KxsYBubWtlyulZEmi6M5/mEJQZQPtFAGllbHPfEiQvBkhi0H5HaFZBxzb84AMOi3REAQqTd2c0DOfF10AwMQBBEWFgYAqampDZ9UA2lqaq5a1dC1SRRz1YANoKpnzeVyLY005ZjynSfUrM7QZ3uBiBA+nGfFYaw5/KjqDy9VBoCF+wchQRDErokOElmdCYJo3rz5okWLJDIpJEFmZmZjx45t6FT48WP0FYCpYmbNteVaGWnIg3bHO+Xi02sGAwDo9nr6WUhUhvpaNOu60J8oOd5PlQ3KZps/8gmCuLltOjSz/yWe3/DvYmlpOWTIkJq3jX2PljR0xaE/ZrkBiH/t1/K3e5fDq90AAEB8J+iueJzjP4clIHj7vIvDgxxoyClZkydPHjhwIN0pJKN9+/bfHeDcuXPjxo3bv3//oEGDnJycpBPsezjzDgcv7W0AorQBVm0C/nzxh4sTAIDo86ttK95NPF9r6KywoNM5v7vQkFOmWIwNjthiwBJn7h5gteFdeDV5f5cYgrffipkyqtbAKeHzLmbeHGko/ZhIhimY+j9+66HHghR/i7arz0RUuZOf5z65+jC664B/DlyR9suv58aeHUddHNkotMlvQi9cKARRVXSuwNCxe0s24yUwOM5TtN6e8701eZf8/2/EZJrZ++qkHZg35ObpBTQGlojevXt7enrSnUJ6hgwZ0q5du3Hjxrm4uIwaNWrz5s06Ojp0hxK/D71xoUBdzMvOFjXz6mrNAQCGgtPU8aLLx7cevTvji0EJprpDa/VpQ5cGzTKmK65sKP1449IFdXFV7ttcZROrmtV5euW1fXuPDB/+5X3VTAcHu/vzhviqXbLG+63RjxOWP71+sVSVqMqKrFQ1drHkQAiAdrdpQ8WX9+9Z4DH+y2HtezgmBy5wX66xUoeqZUw2Cu2DIxseHAEAAN32F26MMmUBAAh0uvn2KBk7YbTx5jY1Q4qVTDZfmZfZZdqeE5foyYoawMLC4sqVK/b29sePHy8uLv7zzz/pTiQ8vW7GaQAAUO045tpwUyZUAIOh0HPjOYd8y427+vb+Ys1kMMdOm5k2eeJBvSE0pZURSYEzRpI3TzN8Nq+qWZ037+hh38lvu2PfLwZluEycqr96+oEJo4d2E9ORFckm/qeN0/86ONJm/MZxRuxzAMDSdNh8oKCL/ZB93ey/GNaoz7h5Ghsnbp9w3rs3RXEaetVxREREWlqaRKL8hxFrj8fHx70PPdlBnDBnd4Tg78/d3PtrFj7buSWYD1/83hmP2jq/+9sHT8pxE1gG6enphYSEmJmZXb16ddeuXXTHkfvl5NP4uHfhx6cqxN77PbL6r48ZrOZjf3MSv98YWvzlQqZs57rYSedJ6GPZXfIyMzMpb6P19Kdxce9DT05ppXb7+u2a1RmMRw20Y+7cEvyPNVe1zdb53TULn4WGpVAejBrSmKUyRRozRMnmaHhsfNSTUxPbfbh7/eXfCxnB1vfq3+HFrs3BFfyaYQmmytjf5/dQK3sa+piiOA0ttKampo6Ojh06dNi9e3dJSYlEMn1NVduwZUub1t1HOliq5iUn1MwhTUfvM/OcxB/jy/+xscuyWHjC20oxW0hRHEQtKyurt2/fDho0aMGCBb169UpMTKQxjKaBeUubNo6jpls1439I/P/KCRyrhb6DPsb/cyljas07c8xGrlx2F72TJ096enpu2LAhKzOLqjY4quZWNq27j5zl3qKqKP+LecqaMn+OuPY8ZVgsPHFmnlNpfgFVeSj25s2bDh06LFmy5NWrV3RnaRQCrwa6urr6+fklJydT1ghb39y6Zdtuo6f3VecVxwv+v+nmPWWekyAlLof/j8G5vmdOLFQs/UxRmoYW2ubNm+/cufPNmzfz58/X1dWdMmUKdeUWgK2j0Qyiw8Iq/p5rTJW+Wy7u8zKt/TXYBnN9p8rGYXH0LWpqaufPn3dycgoJCRk6dKhYTPdhQ46pZjPRs7Dn5V981meq72ADhVoDMo085kyuda2FLBk2bFhQUNCqVavatG1DXitOWVNs8xZ67Ly0/6/OAJbuk/Z5mdZec9kGfbdcHNBSnbIk1Orfv395efm2bducnJx8fX1zc3PpTkSz4SOGP3z4cO3ate3bt9+1axelvcIxzFqoCAuCX5TVfKLS0u3aTm/DrxYyfc+N0zy4VOX45qXJdbq9RywWm5iY1EywU6dOqampkrq9pzGg6/aes2fPNqTFJqCystLNzQ0AvL29+fwfveZeUrf3NAa03N6joaFRszpPmzZNLBYTErq9p5GQ/u09u3fvrpmlampqly9flmbrjVDnzp1rZsiIESPItVsyt/c0Dj90e4+BgcHp06cvXLjwg9X6yx2OiIgIMzMzfX39HxxXVowbN27y5MlMJpPBYLBYLAaDwfwb+brmQxaLxfxKeno6l0vZ5lITpaioePv27TFjxpw/f97Gxubq1att27alOxQNuFwu418AAJPJBPLe/H9HDvbfw9TQ0NAoKioimz506NC5c+fc3d2rq6v/I6HM2bt378GDB7+eS9+djQwGg5yT/zZwzXyGv/9ryH8VFBSqqqoAoKSkxMfHx9HRsY9bnzlz52hpadE4H0jbt28ndyf+41t/F3yxjMH3ljc+//9Hbs+fP3/p0iUPD4+ysrJ/CSjzvl1oz549e/369R+fyqVLl8hNb9L06dPZbPa+ffsamq4xGTZsGJfLFQgEIpFIIBDUvBAKhUKhkHwhEon4fH7NAGKxmBxMKBTa2dndv3+f7i8he1gsVmFhIQAQBGFkZER3HHosXrxYVVVVLBaLRCKCIEQiEfma3NckX5C+HODrT74chSCIrwcgP5STk/uy9bKyMiMjI7I7kSajW7du/fv3/3JG1cyNL+fqdweoNQ9rfV4zpEgkqim0JDk5uR7OPRpDlQUAZ2fn9evXf/01v7lE/dt8+HqUmmXsywEAQCQSVVZWMhgM4u8TEyKRSFtbW1FRkdbZQKFvF1pzc/N58+b94CTS09Pnz59PvlZWVj569Ojw4cOXL18umYCNxoABA4YOHUp3ip/O6tWr7927x+Vy799/oKmpSXccekyePPnLszNUs7Kyqnnt4uJy4cIFbW3tkydPSi2AFLRv337hwoVSay4gIGDChAk1b9evX//rr79KrfXv6tixY8eOHaXZooeHR02V7dy588WLF01NTc3NzaWZQZoaesFQVVXV0KFDORzOgAEDJk+e3KNHDxUVFYkk+ydR/pu7N0PfvU/JkdcxNeF2Hu7ppMFh/HMYovzZuT8S1BaN7f7izJEYra6T+nWhIAmSktjY2IkTJ758+XL48OHHjh2jrQNkYUXUncuP3yUk51VpmtnYdHEb5GAmV3vRq35xen9wjqL31PFFNw7K9LIXHBxMXuY9bty4sWPHOjs7U7EvW5Edf+li4MfUrCoFLauOrv+2Oh8MzezqM6VN3m3yhaOFxrcn17jl5OQsWLAAALp27TpjxgxnZ2dj4wZ1aUJkBe+8kNxvzqSWeSE7LyT3mzNBI+TEsTTt5ZNkoyO5yMjIO3fuAICPj8+ECRNcXV3l5eUl3oqoPOfOpYvvPqbm8uWMbex9fLxM1eVqD1T84vThx82cB7uKIqhdxhp4yvfWrVszZ87Mysqq9blkL4YqfHHGgMNksDUc3dzb6ikxgDnlcMhXQ4kyfnNmdxpPCFO3OGi2nbRNIk0TEroYqk7wYqjq6mobGxsAcHd3FwgEdRpXshdDvQpYxWEwGJot3Nx76iswgaW1JzSj9kCi4i0OmiDf4kpivmSXPelfDDVz5sy1a9eWlpbW+lyiF0MJfx1gw2BrmHXt39Pe+l9WZ3HGb84KwFkT9PHvF4kSal3aF0Pt3bt34MCBkZGRkpqg+NkvzTXbXOSJ/37Bj1zQnmU3QlLTp9rSpUsXLFiQm5tb63PJXgx1ZtkgBoOtYunU17mTIgN6LDjwjYGStzrJM8fsDJT4Mibhvo7d3Nw8PDwaOJHvunr+VJZC6wkXgo54GLMKI/au2Pw+PxMEOQdW/Xo65L2IreI8bsHGaZTHQFIgFAqPHDmydevWysrK8+fP+/j4sFiSfpJGXeKcP3Va0H5G4PWdAw3lSp75L9tyrzgzUZSVdubQyVMPoyoU9Gx7Dlo9t+n0lLl+/XqqTxyK3+88FVoy/nrUHx7GcrzMvQvmkavzszNHtpy+m10lr2/X49cVC/QoDSFFI0eO9PX1leAEGQ6bcj9vAgCoebEjUoZu3V66dCnlJ6cFcQFnQ0x9/wzdNsCYU/Vq95INHz+XgLDqBOdfkwAAIABJREFU6bkV206+z61UMWzju2rlYFVqU9RoaKFls6Vxt+qn+ESw8p7Tx5gFAJqd5hy8DEBk7x2w6FLVo8inVq/XtBux2MK7b38pREEU27179+LFiwHgzp077u7uNKchSuOTCvRHTe5vKA8Aao6zD1ydDeLSg+4tZwcLdj4Max80edDqSUYt7ivTHFRipHB5TnnIoyzlFnP6GMsBgKJhzeo8YP7dwQfuHbF8MMBnvZ+exUEat68kqpFc8dR4SGOGFIcmFigMnNLXWI4BoNhx/r5AAEg9OMxrbtX4Xc/+aPWr17BF63QHb6PiROc3yEanDgwAYLH/ud4JnwRHccTNjy6eBUQFg597L6ISC62sS0tLI58Dv27dOvqrLAC56HFqbU0K0x++KRSz9YIDtkZXEopMEeR8oiedbCJv/vh6dS4mmIl3Ty17Wc1UZCZ9TAcbeuKhpoABAAzOPxcywZPHkSVCw3f3Z/z6ppIpl5qSCPCdp4pJimwUWiNLM3j24Fj43J3ddZmfwzbPXhXdanR/McFUad7B3p4BfBMjrqU5B97QHVSiLl682GQe/+7t7f3fT8orLy/fuHGjv7+/oaHhzZs3u3RpHBcTMVSsTDWD7p8N9W3tos0sfrx15pobLceNEBMAbEXLtvYWTGsja5duHVu+vkh3VNmh3LWbbvmBY+G5O7rrsirTNk+aQK7OACxDq7b2ZiwrY0sFWwf4eIfupEhmqTqaafKun326ZF2v5gxe2KapKz9aXnURiwF0TKzt7c0FlsZWzWwAKO+onyQbhXagz8jl+yfvcbOL9+xe8uzeyyzenDNbvNr2mznhbmSJV+ucoG0BmXt8V9AdU8ICAwMDAwPpTiEZVlZW/11oly9fvm/fPmVl5cuXLzemnj3Y3iOH7pm+1bXNbe9upi9u38oQ6B7b4d1lwJ6gU8nxH9Ih4dye4Izlrd2azKFjKWB2WDrc/vB2N7uHvXubl0bfDIsjV2eT28fiE+I7V6fs839ov9p2COP7k0Lo2+TajvbpMvn3vrY3XVyMKm7fetpj1UkNz84DjW/difswpI3o+r4Dn5yW+vWT0oorG4W2ebcRgRvuzt51497lyyCvYzVi9eLB9koKO+b27rl+2WyCwew2Z+9YbUY23TklZcXyFePGUfgUYmmaM2fOdx/Wcffu3cOHD6urq1+8eLExVVkAgG6jfX+/e3/bzfdXLr9n6rYeuPyPkR30Ffac3sGf8cvhTTehmY7b0jH92lzdSXdQWcKeu2bt/aEz3t86G8NSshrxO7k6X95SNWDlsfmVYpZZryMj+8P5g3TnRDJs1Nxfbz+ICnp351IUS83OZ8W0IaCuuPf8pm6Dl81cdB3UTPZMHw0grT0ZSV3NXAslfR0LKzNTU/MrvrjZQ8QvzPiUkvlZIJZkO7VI//aepmTUqFEAQHZP/0179uzhcDjOzs5paWkSaZGKvo5FFZ9T0zLL/3mfUXFeVkYhTyTBZr5CS1/H3yT5vo6FlZ8zPmXkFX35WWVxfkrmZ2rnKR19HaMfQUFfx6LKgszUzNwvV1x+ZXHKpwyqFzIJ394jVSxFg1r94zA5GoamMnkTOwIAgB07dixatMjc3PzKlSuN+eJMppKmyVcdZqjp6KvREaaJYClqGprW+kxRTdsM5ymSGKailkGtPtU4impmptJeyBr6mDyE6m3NmjWLFi3S1tYODQ1tzFUWIYQaQqb2aFFTQRDEkiVLtm/fbmxsfObMmZ/2aQEIoZ8BFlokbXw+f+TIkX/++aebm9u1a9ea8CM7EEIIsNAiKRMIBAMGDLh//z6Xy71582YTe/gaQgh9Dc/RIumpqKgYM2bM/fv3HRwcrly5glUWIfQzwEKLpCQ9Pd3e3v7ixYt+fn7Pnj1rbPfLIoQQRfDQMZKGz58/9+jR49OnT3379iXvS0YIoZ8EFlokDX5+fjweb8SIETt27KA7C0IISRUWWkStyspKAKiurg4KCurTpw/dcRBCSNrwHC2ilpKSkoqKyrFjx7DKIoR+TrhHi6hlaWn5+vVrKysruoMghBA9sNAiavn5+TEY+MAzhNDPCw8dI2phlUUI/eSw0CKEEEIUwkKLEEIIUQgLLUIIIUQhLLQIIYQQhbDQIoQQQhTCQosQQghRCAstQgghRCEstAghhBCFqO0ZaurUqaamppQ2IQXp6el0R0B15ubmJi8vT3eKhsrJyaE7wv9t2rTp4cOHdKeQgLy8PLojoG87depUUlIS3SkkIDEx0c7OruYtVYW2efPmtra2AFBcXExREwDA5/NLSkp0dHSoawIAVFRUbG1t1dTUKG0FSUqzZs1sbW15PB6Px6O0oeLiYnV1dUqbUFBQsLW15XA4lLbyI6ytrUtLSyldnQGguLhYTU2N6t7EbG1t9fT0KG0C1YOVlZWSklKTWcZMTExq3jIIgqC0PUr5+/svXbr0w4cEQ0MDurOgn0vh58I2bdukpaax2Cy6szQddnZ2mzZt8vDwoDsIarKcnZ2HDh3q6+srzUZl+BwtQRAnTpyoqKjw9h5cXV1Ndxz0E+FV8nyG+mRlZU2eMlksFtMdp4k4euTou3fvxowZ8/HjR7qzoKbp9u3boaGh8+fPf/bsmTTbleE92osXLw4fPpx8fePGjQEDBtCbB/08li5dunXrVvL14cOHp0yZQm+eJiApMYlryxUIBADQuXPn58+f4+MokGSVlJRYWloWFBQAgKmpaVJSEoslpcNRsrpHSxDE+vXra94+ffqUxjDop8Kr5B05cqTm7aZNm3CntuH81vqRVRYAXr58mZiYSG8e1PRs27aNrLIAkJqa+vr1a6k1LauF9tq1a9HR0TVvT506VVpaRmMe9PM4eepkUVFRzdukpKRLFy/RmKcJiIiIOHv27JefnDhxgq4wqEn68OHDjh07vvxEmsuYrBbaM2fOfPk2KytryZLFdIVBP5WTJ0/W+uTM2TPfHBL9oNOnTtc6KnDo0CHZPauFGqETJ05UVlZ++cnBgwf5fL50WpfJQhsdHR0XF7dkyZKRI0cCwNatWydPnnz16tVz587RHQ01cdevXS8vL1+5cuX+/fsB4NKlS7/88ktKSsqrV6/ojiarCgsLQ5+E+vr6njlzRktLa9q0aWvWrLG0tFy2bBnWWiQRVVVVjx49mjZtmr+/v6mpqZeX17Zt25ydnSdMmCASiaSRgJBB586dq6ioIAhi5cqVABAYGEgQRHV19bFjx4RCId3pUJMlEomOHj0qEAgIgggJCQGA7OxsgiB4PN6pU6foTier7ty5U1BQQL7W1tYm66tYLA4MDExLS6M1GmoiwsPDMzMzydctWrQYMWIE+frx48dv376VQgBqe4aiyIgRI77+UE5ObuLEidIPg34eTCZz0qRJX3+uoKAwZswY6edpGtzd3b/+kMFgDBw4UPphUJPk6Oj4zc979OghnQAyeegYIYQQkhVYaBFCCCEKYaFFCCGEKISFFiGEEKIQFlqEEEKIQlhoEUIIof+1d+dRUZzZAsBvA910s9PsiBJARDYRFcQFVHQgLhgVTVRGfepo4kaIBiZqIsQTjY4maBLFuGTExOQpYoj7oARREMKqyCrKrrKjNN1001TX+6PecM7LO5nYS1V14/395zl8916wqm8tX38fjbDRIoQQQjTCRosQQgjRCBstQgghRCNstAghhBCNsNEihBBCNMJGixBCCNEIGy1CCCFEI2y0CCGEEI2w0SKEEEI0wkaLEEII0QgbLUIIIUQjbLQIIYQQjbDRIoQQQjTCRosQQgjRCBstQgghRCNstAghhBCNsNEihBBCNMJGixBCCNEIGy1CCCFEI2y0CCGEEI2w0SKEEEI0wkaLEEII0QgbLUIIIUQjbLQIIYQQjbDRIoQQQjTCRosQQgjRCBstQgghRCNstAghhBCNDNguQDkvX74sKyt7/vz5s2fPOjo6bt26BQDffffdgwcPhEKhUCj08PAYM2YMl8tlu1I01HR0dJSVlbW0tDx//ryrq+vRo0cAkJCQYGtra2Vl5eDg4ODg4Ovra2FhwXalOoMkycePH5eXlzc3N3d1dfX29orF4oyMjB07dgiFQltbWzs7Ox8fn2HDhrFdKdJhdXV15eXljY2NnZ2dvb29nZ2dJSUlH330kVAotLGxoY6xESNG0FsEqQsGBgbOnz+/ePFiIyOjP/2NjI2NQ0NDb9++zXbVaCiQSqXHjh0LCwszNDT802NPIBAsXLiwuLiY7aq1XW1t7bp165ydnf/0T8rhcCZMmPDpp592d3ezXTXSJU+fPo2JiRk1atSr9EFvb++4uLjW1laaiuGQJPkqdbCoubl5zZo1N2/epP5paWnp7e0dHBw8ZswYR0dHLpcrl8tra2tLS0vLy8tzc3NFIhEA8Hi8yMjIbdu2jR8/ntXykQ4rLS1dt25dfn4+9U97e3sfH58pU6b4+vpaW1vzeLy+vr729vbS0tK7d+9WVFR0dnYCgJGR0dq1a7du3frGG2+wWr42EolEx44d27dvX1dXFwBwuVxfX99p06aNHTvW3t7e1NSUIIiurq7Kysq8vLyysrLHjx9TA93c3L788suIiAgOh8Pqb4C0nUwmS05Ojo+Pb2lpAQA9PT0vL6/p06ePGzfOwcHBzMxMoVD09PRUVlb+9ttvZWVlVVVVVB90cnLau3fv8mXL9Q30NVuS9jZahUJx5syZb7755sGDB/b29nPnzvXz85s8efKYMWP+w5nW19dXUlLy6NGj9PT0K1euiESisLCw995778033xQIBEzWj3SXTCZLT08/duzYtWvX3Nzc5s+f7+PjM3nyZA8Pj/9w7JEkWVZWlpOTc/369fT0dLlcvnDhwo0bN4aEhOjra/i81UXl5eWHDx8+e/asVCoNCQmZP3/+qFGjJk6caG1t/R9GNTY23rt3r7q6+uLFi6WlpXZ2duvWrYuJibGysmKscqQramtrDx06lJyc3NPTM2nSpLfeesvDwyMoKMje3v4/jHr27Nm9e/dqamp+/vnngoICS0vLNWvWxMTEODk5aawymu6U1VReXu7v7w8AxsbG0dHRvb29KgSRyWSJiYkmJiYA4ODgUFlZqfE60dBTU1MzfPhw6tj7/PPP5XK5CkG6u7tjY2Opp83e3t7Pnj3TeJ06pLe396233qI+cBYtWqTamahQKFJTU728vADAxMTk7t27Gq8T6a7+/v6//e1v1HVwaGhoXl6eanEyMjKCgoIAwMDA4OrVq5oqTxsbbXFxMdUdR40aVVdXp2a0y5cv83g8AAgICOjv79dIhWioIghiypQp1GmWmpqqZrQTJ05S3SUiIkIj5emo6Oho6u+wc+dONUMRBBEZGQkALi4unR2dGikPDQG7du2ijrFNmzapGUqhUKxevRoA7O3t6+vrNVKedjXagYGBn376adiwYfb29jt27GhpadFI2KdPnyYmJtra2o4YMSIzM1MjMdEQ09/ff/jwYTc3NysrqwMHDjQ0NGgkbEVFRXx8vJmZmb+//+nTpwmC0EhYXXH79u2IiAg+n79u3brMzEyFQqF+TKlUmpyc7OLiYmlpGRsb+/LlS/VjIt1VXFz817/+lc/nv/POO1euXBkYGFA/plwuv3Dhgqenp7Gx8bvvvtve3q5mQC1qtARBzJ8/HwBGjx4tkUg0Hj8rK4vD4QiFwufPn2s8ONJ1Bw8epK6Ib968qfHg586do4J/9913Gg+utTIzM6nfet++fRoPXllZaW5uDgCbN2/WeHCkK4qLi/X09ABg+/btGg/e2NhIvdyNiopSM5QWNdqUlBTqtFT/kd0f+fbbbzkcjpeX14sXL2hKgXSRWCx2cHAAgIMHD9IRX6FQbNy4kXob8vrc1IaFhQFAYGBgX18fHfHv3r0rFAqNjIzKy8vpiI+03zvvvAMA7u7uNH2kV1ZWOjk5cbncjIwMdeJoS6Otqqp64403XFxcUlJSNPJ86Y/s2bMHAFxdXWtqaujLgnRIZmamh4eHk5NTdnY2fVkUCsWlS5esrKwmTZpUWlpKXyJt0NnZuWbNGoFA8OWXX0qlUvoSNTQ0+Pv7W1hYJCUl0fq5gbSNRCyJi4vj8/mffPIJra8P2tvbg4ODjYyMdu/erfJzaa1otCKRyM7OTigUMnCjqVAoFi5cCAArV66kOxfSfk1NTdQ6YsnJyQykO3ToEAAwc6izhSCIgIAAAIiJiWEg3Z07d6gnYXfu3GEgHdIS1Mf4qlWrGMhVWlpKHWOXLl1SLYJWrHV85cqV1tbWZcuWUS9daMXhcJKTk11dXS9duiSRSOhOh7RcamqqXC4fNmzYksVLGEgXFRVlbm7e1dWVlpbGQDpWZGdnFxQUAMDKlSsZSDd16tTw8HAAuHjxIgPpkDZ4+PDhzz//DEwdY76+vuvXrweAwfebStNs51cBQRCBgYE2Nja1tbWMJa2vr3dwcAgODu7q6mIsKdI2IpHIzc3Ny8uLWhqGGTk5OY6OjmPHjlXtG7rab8GCBXw+PynpGGMZRSLR22+/bW5uji9rXxOrVq3S09OLj49n7H1Bf39/dHS0QCBQ7cEJ+432+PHjAHD9+nWG837yySegielkSHe99957PB6vsbGR4bzZ2dlA28Qrdt2/f5/D4cTHxzOclyAIOzs7b2/v12eu2WurpaXF0NCQmYfGvzNy5Eg7OzuRSKTsQJYbrUKhcHd3d3Z2Zj51RkYGAHC5XFys/PXU1tZmbGwcGBjISnZ3d3cnJ6eht4JKZGSkiYmJWCxmPvWyZcuoh3vMp0ZM2rZtG5fLbWpqYj71hg0bAGD//v3KDmT5HW1CQkJNTQ11hjAsJCQkKChILpf/8ssvzGdH7CJJcv369WKxOCoqipUCli1b1tzcHBcXx0p2mlRXV6elpS1auOhVdtnSuKVLlwLAtm3bcO7FEPbs2bNjx46Fh4drciHiV0YdY4NbYrw6NhutVCrdv38/AMybN4/57AYGBkeOHAGAGzduMJ8dsauhoYGajhQREcFKAVTew4cP9/SIWCmADrdu3SIIYu68uaxknz17tqWlZWNjY25uLisFIAZkZGSIxWJqaSPmBQcHu7u7d3d3Dy7G8orYbLSVlZUymYzD4YwZM4aVAsaNGzdq1KiKigpWsiMWUf/pTk5ObO1k5+PjY2hoSJJkRUU5KwXQoaqqCgB8fX1Zyc7lcmfNmgUAjx49YqUAxICamhoA8Pb2ZiU7h8NZsGABADx58kSpgWw22qKiIgBYvHixqakpWzVER0dXV1dT24ii10dxcTEAbNy4ka3NTfl8/vLlywcrGRry8vI8PT09PDzYKiA2NlZPT4/6chEaknJzc62trceNG8dWAdHR0cbGxso+NWH5jhYAVq1axWINq1evlsvlly9fZrEGxLyHDx8CwNq1a1msYc2aNfDve+uhobq6etGiRdTas6wICAjw9PSk/nPRkFRRUREeHs7n89kqwMnJaerUqWVlZUqNYrPR1tTUmJiYzJgxQ7lhiu7akoKS6kYAaK4uzX9Q91KNreuNjIyGDRt269Yt1UMgHfTkyRM/Pz9bW1sWa5g4caKVlRX1KGwIKC8vF4lEbL3zHjRz5syGhgZ2a0A0efnyZVtb25w5c5QcR754UpL/oFoGAPK20oKi2h6FOmWEh4c3NzcTBPHqQ9hstM+fP3d3d1d6gqIe9+k/3w0KXZ4vefhfs6Yvu9BiqN7DPwcHB2UvT5Cua2trGzt2rJKDFPXp/zx65Gh25XPoK7/y7dH/zihRpwYul+vp6fn8+XN1gmiPwsJCfX19avHFV0d21X535Mgv9yoApBWXjh9PuaXWRyBAQEBAR0cHMaDEhyDSFQ8fPhwYGJg8ebKS4ziG9Wcjgqf/vVBcsXfxxIUxrTy1ekZQUJBUKq2trX31IWw2WrFYrNIthUnwZ4njBiqiIzfkgc8PO4PUfIhgYmKi7FxtpOskEgm1AZYy9Oz0y5P+vuXDpJSKf2xYsWHzrUcdapZhZ2c3ZL6L0tLSYmRkpOxzY46xflnSJ6u2f9N/P3Htyo3/zK5S8yPJ0dGRJMm29jb1wiBtRF2VOjo6KjtQMDPhLU/OiS2L3z2a5x/5ziS+Wo122LBhANDS0vLqQ1j+eo+lpaUqI82mbVo97bcbOaHr3pvE5wz01s4JmPJja++ASmUYGRn19PSoNBTpKplMJhQKlR0lmLn3yvdxbSl7Zh8s4oTtjIsKVbMMKysrqVSqZhAt0d3dzePxlB5m6Lz/UvKY5l985n/+m+n0hOgVapZhY2MDAB0d6l4DIS3U1dVlaGioymEGJus3rpXl3ch+Yf/u2iiQixv2zx6/co9qPYO6P1RqCi2bjZbD4ag657Mv904+z5CXk3lPCrI7H8y7VZwXFRLzL5mKb2vZmnqK2KLqscdzXrgr1AkaFS7Ldm8fZabfX3AkKmi0V+iaUrnqlag4Uvuo9rtwXSMiQ0bUNMvslu+e6UZtKyLeGRc/RC5AkEapfL7k52YpeIY8efPde0VExt9nfXqr5NwX72X2aba8P8Jmo9XX1+/rU+X3lN5OSK3kxh/fZFD088eFROjxrFk+ARcfnJir0ttauVyu0iUS0mH6+vqqPbOV3/n0ank3r6/iaPRnzf3dR7ft/lGwaPawxk3fq/KqVSKR6OvrqzBQCwkEgoEBlW4QxPdSrpfxufKWk9G/PpMTWYkrZgd/deOhag+oxGIxABgJWFiaCtFNIBBQq5YqPVKUfTatPDDh+CYv85/Ppcnf/Cb/sxne78T98BeBCmX09vZSxbz6EDYbrYWFRX19vdLDZA1ZFcL3v/wmbsWepP3RJvdzmwfUmHYM0NXVRT1zR68PMzMzZb9yDkA0pO0MW/KVx9rPUjZOtChM3H3kVPp9iV/klojJ/tnpyq0UQ6mrq7OwsFBhoBZydXXt7e2VyWRKjSK6H22fvaRp7Mr8H98fT5Tu3vutwmvulk92eVlxVSvj0aNHBgYGw0cMV2040mbu7u4KhUKpWUgAAEA0ZJe/GfuPlNgVn5//Z+xfXO48U/UBFAAAVFdXA8CoUaOUGKPpVZeVEBERMXiFohZFx2wvj5iLhS0q7dsxfPjw5cuXq1sD0ikTJkzw8/NTN0pfyRxz4zFfNWce2QbLzio7WqFQCIXCsLAwdcvQDuXl5QCQm5urgVgDdbP+slTpHVJIkiTJLVu22NjYaKAGpH0kEgmHw/n+++/VD/Xiy7ARwSsL2gZUGPvFF1/w+XylhrB5R+vg4NDX16eBb5dzzL0c5Yc+/Dq/X+lbW5IkOzs72Vo0DrHFzs7u8ePHcrlaF7bAtfNx4pYW5ta3Nrv7KPtlIairq+vq6lJ+8rOW8hjlweVyCwsL2S2jtLTU2tqa3RoQTQQCgYWFxf3799UPZRYUwim9caBYuQcwlPv37ys7lZLNRjt69GgAOHv2rNqRDA7efEI+OR2h/KTtq1evSqXSyMhItWtAusTb21ssFqekpKgVRd9+x5mTic55ZfqTU7eMVnb0mTNnAMDLy0utGrSGvoG+q6tramqqBmJxLFasiFRh3sTT5qcFBQWenp4aqAFpJXd39ytXrigUan7dGjiTdta/aD0XrvS7fLFYnJ6eruw6o2w2Wj8/PwA4c+aMUktsaNbXX389fPhwd3d3tgpArKD2saC2b1IDx3xcZMzugwd3RfuaKncqkSR56tSpwUqGhnHjxt2+fbu9vV3dQHoWK1csVqHRHk06KpFIAgMD1S0AaauAgIDq6moW11P76aefWltblV2Yhc1GS114dnR0KP9yWzN6enqys7OVe6eNhgTqgjQ/P5+aQMi8pqam5uZm+PdZMDRQe6qwuM7apUuXAMDV1ZWtAhDdqDOXxRXCqWc2yt6bsdlo7e3tqWe2165dYz47SZJbtmyRSCTU1lroteLn5+fr6zswMHD16lVWCqCO+bCwMGdnZ1YKoENISAgAXL9+nZXs+fn5ZWVlpqamVBloSJo+fTqwt4l4dXX1zZs3uVyuskv0s7xgRVJSkrGx8fnz55nP/uTJE+olGVt7CCMWcbncQ4cOAcCFCxdYKeD8+fNcLvf48eNDacGKqVOnenh4qPvmW1VpaWkAsHHjRjs7O1YKQAzw9fWdOXNmamqq+q9pVZCWlkYQxKJFi9zc3JQayGajBQAbG5slS5YUFxdr4L2Okn799VcA8PDwYHH7TMSiGTNmjBs3Lisri/kztqenJz8/PyIiYijdzgIAh8N5//336+vrs7KymM+enp5uYmISExPDfGrEpNjY2M7OzuTkZOZT37x5k8PhxMXFKT1ShW8RaVZ3d/fw4cMDAgJ6enoYSyqVSv39/R0cHO7fv89YUqRtqqurzc3Nly5dKhaLGUva1tY2bdo0BweHtrY2xpIyZmBgwN/f39HRMT8/n7GkCoXi4MGDPB4v9UIqY0kRi6ZPn25ubn7t2jUmk/744488Hu/rr79WYSz7jZYkyT179gDA4cOHGcu4evVqPT29e/fuMZYRaafNmzcDwKJFi5hJRxAENV8xPj6emYzMo2ZTC4XC7u5uZjIePXoUAN58801m0iHWUW98eDxeU1MTMxmpmQdBQUGqDdeKRktNIQsICGAmHfVKODAwkJl0SJvdunWLerRTXFzMQLqbN29S6UpKShhIx4qOjg5zc3MAOH78OAPp2traqGUsT548yUA6pA0kYgm1Wd6BAwcYSCcSiahler/44gvVImhFoyVJ8ty5c8bGxosXL66rq6M10bVr1/h8Pp/Pz8jIoDUR0gkEQezfv9/Y2HjqlKl034E1NTWNGTPGysrq9OnTtCZiXV5enre3t6OjI90PjeRy+ZIlSwBg1apVEomE1lxIq1RXV0+dOlUoFF69epXWRAqFYu3atQAwZ86cFy9eqBZEWxotSZIff/wxAFhaWjY0NNCUoqWlxdramsvlXrlyhaYUSBdlZmYaGBi4uLjQd+wVFRVZW1sbGRlVVVX022vvAAAFsElEQVTRlEKr9PX1OTo6cjicb7/9lqYUMplszpw5AJCQkEBTCqTNCIKgVkHYsWMHTSkUCsW6desAYPXq1erE0aJG29PTs2XLFoFAMGHChIKCAo3HT0tLs7Kycnd3Lyws1HhwpOu++uorPT09CwuLlJQUjQc/efKkkZERn8/XyHrouiIjI4NadnjXrl0EodKOH38sKyuL+orFBx98oFAoNBsc6Yq8vLzhw4cDQExMjAb2p/m/CgoKqOUL16xZMzCgyvYDg7So0VKKiopMTU2pKwhN/eEUCkViYiKXyxUIBEP43RhSU0pKipmZmb6+/t69ezXVGKRS6aZNmwDAzs4uOztbIzF1SGtr6/jx4wEgODhYg/NWrl+/bmJiAgBbt27FLvuaE4vFYWFhAODr61teXq6psPm/5VM7B7z99ttqdllSCxstSZIHDhygJoxs3bpV/Wjd3d2hoaEAYGJicvv2bfUDoiEsLy/PzMwMAKZMmdLe3q5mtMbGRmqFRVtb2ydPnmikQp0jkUiojROsra2LiorUD0hNZuRyufQ9lEa6hSAIaoFrExOTrNtZ6ge8ceMGj8fjcDgJCQkauZLTxkZLEMTly5dXrFjB5/O9vLw+/PBDFc7P/v7+zMzMzz77zNXVlc/nh4eHa2anTDTUFRQUzJs3TyAQODs7f/rpp5WVlcpGkEgkly9f/uijj+zs7MzMzJYuXVpWVkZHqbqisbHxgw8+cHJyMjMzW7t27Q8//KDCvLOmpqZDhw7NmzfP0NAwMDDwxo0bdJSKdFRra+vOnTvd3d2NjY2joqJOnTqlwoVyS0tLUlLS4sWLBQKBt7f3xYsXNVWeNjbaQenp6ZaWltTdbXBw8IkTJ/r6+v50lEwm++WXX6hn6wDg5+fH2Het0JDR0tIyYcIEADAwMFiwYMGFCxfkcvmfjpJKpadPnx5c1D40NJTJZVi0HEEQK1asoP4yNjY2+/bte5WpZwqFIjs7e8OGDUZG/7uj2Z49exioFuko6k0NAFhYWHz88ceveKFcUlISGxtLPc0CgLi4OM1WpdWNliTJ9vb2rVu3Dp5jzs7OcXFxqamp//+KuLOjMz09ff369YO92dDQcMmSJUNy/R3EgI6OjqioKC6XSx1OXl5eCQkJ169f7+3t/d1Pvnz5Mi0tbfv27YMt1tLScvPmzSKRiJXKtZZcLj948KCLi8vgynRz5849c+ZMa2vr736yv78/JycnMTExKCho8IenTZuWnp7OSuVIVygUilOnTlEbSVFmzZp14sSJp0+f/u4n5XJ5YWFhUlLStGnTBn94/Pjx586d0/iLfw5JkqD1mpub//Wvf1VVVeXk5FRUVLx8+VJPT8/U1NTIyEhfX58giN7eXpFIBAA2NjY+Pj6enp4hISFz5syh5lUhpLKampr09PSqqqrc3NyqqiqxWKyvr29mZsbn8/X09AiCkEqlIpGIIAgzMzNPT8/JkydPnz49PDzc0NCQ7dq1FEmSmZmZWVlZZWVlJSUl9fX1AGBqasrn87lcLkmSMpmsp6dHLpcbGhq6ubkFBgZ6e3vPnDnT39+f7dqRbiBJMicnJysr6+HDh0VFRXV1dQRBUMcYj8cjSbK/v7+np6e/v9/AwMDNzW3ChAk+Pj4zZsyYOHEiHfXoRqP9na7OroxfMyoqKlpbW+VyOY/Hc3Jy8vb29vPzGzFixFDaDgVpFZIknz59evv27erq6q6uLqoTWFlZeXp6zpgxw9bWlu0CdVJvb29mZmZpaWlHRwd1HWNubj5y5MjJkyePHj1aT4/ljU/QECCTyTJ/zbz/4H57e3tvb6+enp6JicnIkSMDAwN9fHwGn1rRRycbLUIIIaQr8GoRIYQQohE2WoQQQohG2GgRQgghGmGjRQghhGiEjRYhhBCiETZahBBCiEbYaBFCCCEaYaNFCCGEaISNFiGEEKLR/wCTgad+G79aygAAAABJRU5ErkJggg==)
One of the main differences between the feedforward networks and RNNs is that the former take a fixed size input at once to produce a fixed size output. On the other hand,
RNNs do not take all the input data at once – they ingest the data sequentially, one at a time. At each step, the network applies a series of calculations to produce the output, also known as the hidden state.

1. Import the libraries:
"""

import yfinance as yf
import numpy as np

import torch
import torch.optim as optim
import torch.nn as nn
from torch.utils.data import Dataset, TensorDataset, DataLoader, Subset
from collections import OrderedDict

from sklearn.metrics import mean_squared_error
from sklearn.preprocessing import MinMaxScaler

print(torch.__version__)

device = 'cuda' if torch.cuda.is_available() else 'cpu'

"""2. Define the parameters:"""

# data
TICKER = 'INTC'
START_DATE = '2010-01-02'
END_DATE = '2021-12-31'
VALID_START = '2021-07-01'
N_LAGS = 12

# neural network 
BATCH_SIZE = 16
N_EPOCHS = 100

"""3. Download and prepare the data:"""

df = yf.download(TICKER, 
                 start=START_DATE, 
                 end=END_DATE,
                 progress=False)

df = df.resample('W-MON').last()
valid_size = df.loc[VALID_START:END_DATE].shape[0]
prices = df['Adj Close'].values.reshape(-1, 1)

fig, ax = plt.subplots()

ax.plot(df.index, prices)
ax.set(title=f"{TICKER}'s Stock price", 
       xlabel='Time', 
       ylabel='Price ($)');

"""4. Scale the time series of prices:"""

valid_ind = len(prices) - valid_size

minmax = MinMaxScaler(feature_range=(0, 1))

prices_train = prices[:valid_ind]
prices_valid = prices[valid_ind:]

minmax.fit(prices_train)

prices_train = minmax.transform(prices_train)
prices_valid = minmax.transform(prices_valid)

prices_scaled = np.concatenate((prices_train, 
                                prices_valid)).flatten()
plt.plot(prices_scaled)

"""5. Transform the time series into input for the RNN:"""

X, y = create_input_data(prices_scaled, N_LAGS)

"""6. Obtain the naïve forecast:"""

naive_pred = prices[len(prices)-valid_size-1:-1]
y_valid = prices[len(prices)-valid_size:]

naive_mse = mean_squared_error(y_valid, naive_pred)
naive_rmse = np.sqrt(naive_mse)
print(f"Naive forecast - MSE: {naive_mse:.4f}, RMSE: {naive_rmse:.4f}")

"""7. Prepare the `DataLoader` objects:"""

# set seed for reproducibility
custom_set_seed(42)

valid_ind = len(X) - valid_size

X_tensor = torch.from_numpy(X).float().reshape(X.shape[0], 
                                               X.shape[1], 
                                               1)
y_tensor = torch.from_numpy(y).float().reshape(X.shape[0], 1)

dataset = TensorDataset(X_tensor, y_tensor)

train_dataset = Subset(dataset, list(range(valid_ind)))
valid_dataset = Subset(dataset, list(range(valid_ind, len(X))))

train_loader = DataLoader(dataset=train_dataset, 
                          batch_size=BATCH_SIZE, 
                          shuffle=True)
valid_loader = DataLoader(dataset=valid_dataset, 
                          batch_size=BATCH_SIZE)

"""Check the size of the datasets:"""

print(f'Size of datasets - training: {len(train_loader.dataset)} | validation: {len(valid_loader.dataset)}')

"""8. Define the model:"""

class RNN(nn.Module):
    def __init__(self, input_size, hidden_size, n_layers, output_size):
        super(RNN, self).__init__()
        self.rnn = nn.RNN(input_size, hidden_size, 
                          n_layers, batch_first=True,
                          nonlinearity='relu')
        self.fc = nn.Linear(hidden_size, output_size)
    
    def forward(self, x):
        output, _ = self.rnn(x)
        output = self.fc(output[:,-1,:]) 
        return output

"""9. Instantiate the model, the loss function and the optimizer:"""

model = RNN(input_size=1, hidden_size=6, 
            n_layers=1, output_size=1).to(device)
loss_fn = nn.MSELoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

"""10. Train the network:"""

PRINT_EVERY = 10
train_losses, valid_losses = [], []

for epoch in range(N_EPOCHS):
    running_loss_train = 0
    running_loss_valid = 0

    model.train()
    
    for x_batch, y_batch in train_loader:
        
        optimizer.zero_grad()
        
        x_batch = x_batch.to(device)
        y_batch = y_batch.to(device)
        y_hat = model(x_batch)
        loss = torch.sqrt(loss_fn(y_batch, y_hat))
        loss.backward()
        optimizer.step()
        running_loss_train += loss.item() * x_batch.size(0)
        
    epoch_loss_train = running_loss_train / len(train_loader.dataset)
    train_losses.append(epoch_loss_train)

    with torch.no_grad():
        model.eval()
        for x_val, y_val in valid_loader:
            x_val = x_val.to(device)
            y_val = y_val.to(device)
            y_hat = model(x_val)
            loss = torch.sqrt(loss_fn(y_val, y_hat))
            running_loss_valid += loss.item() * x_val.size(0)
            
        epoch_loss_valid = running_loss_valid / len(valid_loader.dataset)
            
        if epoch > 0 and epoch_loss_valid < min(valid_losses):
            best_epoch = epoch
            torch.save(model.state_dict(), './rnn_checkpoint.pth')
            
        valid_losses.append(epoch_loss_valid)

    if epoch % PRINT_EVERY == 0:
        print(f"<{epoch}> - Train. loss: {epoch_loss_train:.4f} \t Valid. loss: {epoch_loss_valid:.4f}")
        
print(f'Lowest loss recorded in epoch: {best_epoch}')

"""11. Plot the losses over epochs:"""

train_losses = np.array(train_losses)
valid_losses = np.array(valid_losses)

fig, ax = plt.subplots()

ax.plot(train_losses, color='blue', label='Training loss')
ax.plot(valid_losses, color='red', label='Validation loss')

ax.set(title="Loss over epochs", 
       xlabel='Epoch', 
       ylabel='Loss')
ax.legend()

plt.show()

"""12. Load the best model (with the lowest validation loss):"""

state_dict = torch.load('rnn_checkpoint.pth')
model.load_state_dict(state_dict)

"""13. Obtain the predictions:"""

y_pred = []

with torch.no_grad():
    
    model.eval()
    
    for x_val, y_val in valid_loader:
        x_val = x_val.to(device)
        y_hat = model(x_val)
        y_pred.append(y_hat)
        
y_pred = torch.cat(y_pred).numpy()
y_pred = minmax.inverse_transform(y_pred).flatten()

"""14. Evaluate the predictions:"""

rnn_mse = mean_squared_error(y_valid, y_pred)
rnn_rmse = np.sqrt(rnn_mse)
print(f"RNN's forecast - MSE: {rnn_mse:.4f}, RMSE: {rnn_rmse:.4f}")

fig, ax = plt.subplots()

ax.plot(y_valid, color='blue', label='Actual')
ax.plot(y_pred, color='red', label='RNN')
ax.plot(naive_pred, color='green', label='Naïve')

ax.set(title="RNN's Forecasts", 
       xlabel='Time', 
       ylabel='Price ($)')
ax.legend()

plt.tight_layout()
plt.show()